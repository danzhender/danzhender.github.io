<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事件队列详解</title>
      <link href="2021/07/12/%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/07/12/%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="基础执行顺序"><a href="#基础执行顺序" class="headerlink" title="基础执行顺序"></a>基础执行顺序</h3><p>先走主进程，再走微任务，再走宏任务。nodejs中，微任务只能有1000个，多出的只能下次事件循环再执行。<br>宏任务：setTimeout，setInterval，requestAnimationFrame<br>微任务：Promise，queueMicrotask</p><h3 id="宏任务与微任务嵌套"><a href="#宏任务与微任务嵌套" class="headerlink" title="宏任务与微任务嵌套"></a>宏任务与微任务嵌套</h3><ol><li><p>宏任务套微任务</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务1&#x27;</span>)</span><br><span class="line">    queueMicrotask(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;微任务2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务2&#x27;</span>)</span><br><span class="line">    queueMicrotask(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;微任务3&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">queueMicrotask(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微任务1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 被宏任务嵌套的微任务，在宏任务后执行，并不会有插队现象</span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span> <span class="number">2</span> 微任务<span class="number">1</span> 宏任务<span class="number">1</span> 微任务<span class="number">2</span> 宏任务<span class="number">2</span> 微任务<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>微任务嵌套宏任务</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务1&#x27;</span>)</span><br><span class="line">    queueMicrotask(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;微任务2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">queueMicrotask(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微任务1&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 微任务嵌套宏任务，也是不会有插队现象</span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span> <span class="number">2</span> 微任务<span class="number">1</span> 宏任务<span class="number">1</span> 微任务<span class="number">2</span> 宏任务<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><p>微任务嵌套微任务</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">queueMicrotask(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微任务1&#x27;</span>)</span><br><span class="line">    queueMicrotask(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;微任务2&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">queueMicrotask(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微任务3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span> <span class="number">2</span> 微任务<span class="number">1</span> 微任务<span class="number">3</span> 微任务<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>宏任务套宏任务</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务1&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span> <span class="number">2</span> 宏任务<span class="number">1</span> 宏任务<span class="number">3</span> 宏任务<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Promise不一样的事件队列"><a href="#Promise不一样的事件队列" class="headerlink" title="Promise不一样的事件队列"></a>Promise不一样的事件队列</h3><ol><li>then是个黑盒子<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;x&#x27;</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微任务1&#x27;</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;x&#x27;</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;微任务2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微任务3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="regexp">//</span> <span class="keyword">then</span>会导致事件插队，会使微任务<span class="number">2</span>插队到微任务<span class="number">3</span>前面（浏览器和Node11以上会插队）</span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span> <span class="number">2</span> 微任务<span class="number">1</span> 微任务<span class="number">2</span> 微任务<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li>resolve也是个黑盒子<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;x&#x27;</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;x&#x27;</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="regexp">//</span> <span class="keyword">then</span>的实现就是如此，不知道原理</span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;x&#x27;</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;x&#x27;</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="regexp">//</span> 单独调用resolve，一个resolve推迟两个时序，resolve实现就是如此，不知道原理</span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="NodeJs的事件循环"><a href="#NodeJs的事件循环" class="headerlink" title="NodeJs的事件循环"></a>NodeJs的事件循环</h3><ol><li><p>NodeJs单独的任务<br>宏任务：rs.readFile(path,fn)<br>微任务：setImmediate,process.nextTick(在)</p></li><li><p>NodeJs事件循环有6个步骤<br>[1] timers ： 处理setTimeout<br>[2] I/O callbacks<br>[3] 准备阶段<br>[4] poll(轮询阶段)：访问操作系统的相关准备是否完毕<br>[5] check ： 处理setImmediate<br>[6] close callbacks</p></li><li><p>setTimeout和setImmediate</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>答案不唯一，事件循环是用C++写的，应用是JS的，有可能是C++先启动的，也有可能是JS先启动,说白了，这两件事情没关系</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="regexp">//</span> immediate timeout</span><br><span class="line"><span class="regexp">//</span> 这样等于是JS慢一点执行，所以一定是immediate在前</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布订阅模式</title>
      <link href="2021/04/19/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/19/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="手写简易发布订阅"><a href="#手写简易发布订阅" class="headerlink" title="手写简易发布订阅"></a>手写简易发布订阅</h3><p>实现思路为先定义一个事件池，每当订阅一个方法，就会查看事件池内有没有相应事件的对象，没有则创建，有则追加。触发事件时，则会执行相应事件对象下的所有回调函数。<br>vue的$emit就是个发布订阅的案例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布订阅模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 事件对象，存放订阅的名字和事件</span></span><br><span class="line">        <span class="keyword">this</span>.events = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 订阅事件的方法</span></span><br><span class="line">    on(eventName,callback) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.events[eventName]) &#123;</span><br><span class="line">           <span class="comment">// 注意时数据，一个名字可以订阅多个事件函数</span></span><br><span class="line">           <span class="keyword">this</span>.events[eventName] = [callback]</span><br><span class="line">       &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">          <span class="comment">// 存在则push到指定数组的尾部保存</span></span><br><span class="line">           <span class="keyword">this</span>.events[eventName].push(callback)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发事件的方法</span></span><br><span class="line">    emit(eventName) &#123;</span><br><span class="line">        <span class="comment">// 遍历执行所有订阅的事件</span></span><br><span class="line">       <span class="keyword">this</span>.events[eventName] &amp;&amp; <span class="keyword">this</span>.events[eventName].forEach(cb =&gt; cb());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除订阅事件</span></span><br><span class="line">    removeListener(eventName, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.events[eventName]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.events[eventName] = <span class="keyword">this</span>.events[eventName].filter(cb =&gt; cb != callback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只执行一次订阅的事件，然后移除</span></span><br><span class="line">    once(eventName,callback) &#123;</span><br><span class="line">        <span class="comment">// 绑定的时fn, 执行的时候会触发fn函数</span></span><br><span class="line">        let fn = () =&gt; &#123;</span><br><span class="line">           callback(); <span class="comment">// fn函数中调用原有的callback</span></span><br><span class="line">           <span class="keyword">this</span>.removeListener(eventName,fn); <span class="comment">// 删除fn, 再次执行的时候之后执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.on(eventName,fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> em = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="keyword">let</span> workday = <span class="number">0</span>;</span><br><span class="line">em.on(<span class="string">&quot;work&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    workday++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;work everyday&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">em.once(<span class="string">&quot;love&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;just love you&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeMoney</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;make one million money&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">em.on(<span class="string">&quot;money&quot;</span>,makeMoney)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> time = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    em.emit(<span class="string">&quot;work&quot;</span>);</span><br><span class="line">    em.removeListener(<span class="string">&quot;money&quot;</span>,makeMoney);</span><br><span class="line">    em.emit(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">    em.emit(<span class="string">&quot;love&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (workday === <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;have a rest&quot;</span>)</span><br><span class="line">        <span class="built_in">clearInterval</span>(time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">work</span> <span class="string">everyday</span></span><br><span class="line"><span class="attr">just</span> <span class="string">love you</span></span><br><span class="line"><span class="attr">work</span> <span class="string">everyday</span></span><br><span class="line"><span class="attr">work</span> <span class="string">everyday</span></span><br><span class="line"><span class="attr">work</span> <span class="string">everyday</span></span><br><span class="line"><span class="attr">work</span> <span class="string">everyday</span></span><br><span class="line"><span class="attr">have</span> <span class="string">a rest</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vueMastery观后感</title>
      <link href="2021/02/19/VueMastery(Vue3%E5%85%A5%E9%97%A8)%E8%A7%82%E5%90%8E%E6%84%9F/"/>
      <url>2021/02/19/VueMastery(Vue3%E5%85%A5%E9%97%A8)%E8%A7%82%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="vue2的几个痛点"><a href="#vue2的几个痛点" class="headerlink" title="vue2的几个痛点"></a>vue2的几个痛点</h2><ul><li><p>随着组件增长，组件会越来越大，越来越丑，因此可读性和可维护性变差<br>options API</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                searchData:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                sortingData:<span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            searchFn()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            sortingFn()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>composition API</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        setup()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;...useSearch(),...useSorting()&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">useSearch</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">useSorting</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对比两种方式的区别，当组件越来越大，options API 写起来如同琦玉的认真往返跳</p></li><li><p>跨多个组件重用代码片段时，所有重用方法都有缺陷</p><ol><li>mixins:会导致属性名冲突，也不清楚这些mixins如何交互，而且还是不能够灵活对应功能进行重用</li><li>mixins工厂:更加复杂，需要命名空间这种强大的规则和约束，并且仍然需要查看每个mixin的内部暴露了哪些属性</li><li>插槽:降低可读性，不够灵活</li><li>高阶组件:从没用过，听说就不是人用的东西<br>Vue3 提供了composition Functions<br>use/search.js<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>function useSearch(getResults)&#123;</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>use/sorting.js<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>function useSorting(&#123;input, options&#125;)&#123;</span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>search.vue<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import useSearch <span class="keyword">from</span> <span class="string">&#x27;@/use/search&#x27;</span></span><br><span class="line">import useSorting <span class="keyword">from</span> <span class="string">&#x27;@/use/sorting&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>&#123;</span><br><span class="line">    setup ()&#123;</span><br><span class="line">        const productSearch = useSearch()</span><br><span class="line">        const resultSorting = useSorting(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">        return &#123;productSearch, resultSorting&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>唯一的缺点是，现在有两种不同的语法用于定义组件<br>mixin是原来最常用的，这是一种交叉继承，说白了就是一个儿子有俩爹，一个爹教你会飞，一个爹教你会游，但是传宗接代后你不知这个技能来自谁，数据和方法不知道是从哪来的<br>尤大:coposition API吊打mixin</li></ol></li><li><p>对Typescript支持有限</p></li></ul><h2 id="composition-API-的基本姿势"><a href="#composition-API-的基本姿势" class="headerlink" title="composition API 的基本姿势"></a>composition API 的基本姿势</h2><p>setup和ref<br>setup没有this，setup是在beforeCreate和created之间执行<br>setup其实可以理解为做初始化，肯定是最早执行<br>ref多数使用场景是基本类型，何为响应式对象，必须要是对象，所以需要ref包装一下</p><h2 id="composition-API中methods基本用法"><a href="#composition-API中methods基本用法" class="headerlink" title="composition API中methods基本用法"></a>composition API中methods基本用法</h2><p>setup中想改变ref定义的响应式对象，需要用这个对象的value属性，模板上引用则不需要</p><h2 id="composition-API中computed基本用法"><a href="#composition-API中computed基本用法" class="headerlink" title="composition API中computed基本用法"></a>composition API中computed基本用法</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;ref, computed&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        setup ()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> capacity = ref(<span class="number">3</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> attending = ref([<span class="string">&quot;Tim&quot;</span>,<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Joe&quot;</span>])</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> spaceLeft = computed (<span class="function">() =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//要加value,因为用的事两个ref对象</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> capacity.value - attending.value.length;</span></span><br><span class="line">                </span><br><span class="line">            &#125;)</span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">increaseCapacity</span>(<span class="params"></span>)</span>&#123; capacity.value++ &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123; capacity, increaseCapacity, attending, spacesLeft &#125;;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>computed返回值是一个readOnly的泛型ref，不能直接改，不然会报错，想改的话必须用get，set用法<br>如果computed放在reactive中使用，等于对ref进行了拆箱操作，则不需要后面跟value</p><h2 id="composition-API中reactive响应式语法"><a href="#composition-API中reactive响应式语法" class="headerlink" title="composition API中reactive响应式语法"></a>composition API中reactive响应式语法</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;reactive, computed, toRefs&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        setup ()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> event = reactive(&#123;</span></span><br><span class="line">                capacity: 4,</span><br><span class="line"><span class="javascript">                attending = ref([<span class="string">&quot;Tim&quot;</span>,<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Joe&quot;</span>])</span></span><br><span class="line"><span class="javascript">                spaceLeft = computed (<span class="function">() =&gt;</span>&#123;</span></span><br><span class="line">                </span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> event.capacity.value - event.attending.length;</span></span><br><span class="line">                </span><br><span class="line">            &#125;)                </span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">increaseCapacity</span>(<span class="params"></span>)</span>&#123; capacity.value++ &#125;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//可以直接返回event对象</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123; event, increaseCapacity&#125;;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//或者用toRefs进行拆箱,模板引用时就不用引用event了</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//return &#123; ...toRefs(event), increaseCapacity&#125;;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>何时用ref，何时用reactive?<br>理论上reactive更常用些，ref作用在于拆分，可以用于业务符合，或者就单个值，直接用ref就完了<br>isRef能判断一个变量是不是ref，unRef可以对ref进行拆箱<br>&lt; script setup &gt;语法糖有的话，就不用考虑这些事了</p><h2 id="composition-Function模块化"><a href="#composition-Function模块化" class="headerlink" title="composition Function模块化"></a>composition Function模块化</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;reactive, computed, toRefs&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line">        setup ()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> useEventSpace();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">useEventSpace</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> event = reactive(&#123;</span></span><br><span class="line">                capacity: 4,</span><br><span class="line"><span class="javascript">                attending = ref([<span class="string">&quot;Tim&quot;</span>,<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Joe&quot;</span>])</span></span><br><span class="line"><span class="javascript">                spaceLeft = computed (<span class="function">() =&gt;</span>&#123;</span></span><br><span class="line">                </span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> event.capacity.value - event.attending.length;</span></span><br><span class="line">                </span><br><span class="line">            &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">increaseCapacity</span>(<span class="params"></span>)</span>&#123; capacity.value++ &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123; event, increaseCapacity&#125;;          </span></span><br><span class="line">        &#125;    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以从不同文件引入<br>use/event-space.js</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123;reactive, computed, toRefs&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="function">export <span class="keyword">default</span> function <span class="title">useEventSpace</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">event</span> = reactive(&#123;</span><br><span class="line">            capacity: <span class="number">4</span>,</span><br><span class="line">            attending = <span class="keyword">ref</span>([<span class="string">&quot;Tim&quot;</span>,<span class="string">&quot;Bob&quot;</span>,<span class="string">&quot;Joe&quot;</span>])</span><br><span class="line">            spaceLeft = computed (() =&gt;&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">event</span>.capacity.<span class="keyword">value</span> - <span class="keyword">event</span>.attending.length;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="function">function <span class="title">increaseCapacity</span>(<span class="params"></span>)</span>&#123; capacity.<span class="keyword">value</span>++ &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="keyword">event</span>, increaseCapacity&#125;;          </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以引用多个文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import useEventSpace <span class="keyword">from</span> <span class="string">&quot;@/use/event-space&quot;</span></span><br><span class="line">import useMapping <span class="keyword">from</span> <span class="string">&quot;@/use/mapping&quot;</span></span><br><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>&#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        return &#123;<span class="built_in">..</span>.useEventSpace(),<span class="built_in">..</span>.useMapping()&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会导致不能清晰看出哪些方法来自哪个composition function,可以用解构赋值的写法写</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import useEventSpace <span class="keyword">from</span> <span class="string">&quot;@/use/event-space&quot;</span></span><br><span class="line">import useMapping <span class="keyword">from</span> <span class="string">&quot;@/use/mapping&quot;</span></span><br><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>&#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line"></span><br><span class="line">        const &#123; capacity, attending, spacesLeft, increaseCapacity&#125; = useEventSpace();</span><br><span class="line">        const &#123;map,embedId&#125; = useMapping();</span><br><span class="line">        return &#123;capacity, attending, spacesLeft, increaseCapacity,map,embedId&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setup理应很清爽，就是各种功能模块调用<br>可复用的话，直接放到use文件夹下的JS文件内，不可复用直接拿到setup外，说白了只是在写js，不是在写vue(有hooks那味了，useState)<br>这样确实利于维护，但是跟hooks用法一样，但是底层实现完全不一样<br>为什么可以解决vuex的持久化?</p><h2 id="lifecycle-hooks生命周期钩子"><a href="#lifecycle-hooks生命周期钩子" class="headerlink" title="lifecycle hooks生命周期钩子"></a>lifecycle hooks生命周期钩子</h2><p>生命周期钩子变动<br>beforeDestroy () -&gt; beforeUnmount()<br>destroyed() -&gt; unmounted()</p><p>在setup中使用生命周期钩子，只需要在钩子前增加”on”</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; onBeforeMount, onMounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>&#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        onBeforeMount(()=&gt;&#123;</span><br><span class="line">            console.log(<span class="string">&quot;Before Mount!&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        onMounted(()=&gt;&#123;</span><br><span class="line">            console.log(<span class="string">&quot;Mounted!&quot;</span>)</span><br><span class="line">        &#125;)        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中缺少了beforeCreated和created，因为实际周期是setup在beforeCreated和created之间调用，也可以理解为放在setup中的代码，就是放在beforeCreated和created中</p><p>现在多了两个生命周期钩子:</p><ol><li>onRenderTracked: render function第一次访问响应式依赖时调用，一般调试时用于查看哪些依赖项在被追踪，</li><li>onRenderTriggered: 触发新渲染时调用，一般调试时用于查看哪些依赖项触发了组件的重新渲染</li></ol><p>setup函数中的生命周期钩子，例如onMounted，其实只是将onMounted传进去的这个函数保存在onMounted数组里，当mounted这个钩子真的触发时，就把数组里的函数都执行一遍，所以setup函数中有多个相同的生命周期钩子则会叠加，并不会替换(发布订阅模式，一个一个订阅，统一发布)</p><h2 id="数据侦听watch"><a href="#数据侦听watch" class="headerlink" title="数据侦听watch"></a>数据侦听watch</h2><p>加入了一个新api，watchEffect</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line">import eventapi <span class="keyword">from</span> <span class="string">&quot;@/api/event.js&quot;</span></span><br><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>&#123;</span><br><span class="line">    setup()&#123;</span><br><span class="line">        const searchInput = ref(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        const results = ref(0)</span><br><span class="line">        watchEffect(()=&gt;&#123;</span><br><span class="line">            results.value = eventApi.getEventCount(searchInput.value)</span><br><span class="line">        &#125;)</span><br><span class="line">        return &#123;searchInput, results&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>watchEffect会立即执行，参数函数中有响应式对象改变时，将会重新运行</p><p>当然watch还是可以用的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="name">searchInput</span>,(<span class="name">newVal</span>,oldVal) =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里如果watch一个ref,那么直接这样写就行了，如果watch一个reactive对象其中的一个值，那要以回调参数的返回值来写?(存在疑问)<br>当然还可以监听多个参数</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([firstName,LastName],([<span class="keyword">new</span><span class="type">First</span>,<span class="keyword">new</span><span class="type">First</span>],([oldFirst,oldFirst]) =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>别忘了watch还有immediate选项</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="name">searchInput</span>,(<span class="name">newVal</span>,oldVal) =&gt; &#123;</span><br><span class="line">    results.value = eventApi.getEventCount(<span class="name">searchInput</span>.value)</span><br><span class="line"></span><br><span class="line">&#125;,&#123;immediate<span class="symbol">:true</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="共享状态-sharing-state"><a href="#共享状态-sharing-state" class="headerlink" title="共享状态 sharing state"></a>共享状态 sharing state</h2><p>B站资源 :<br><a href="https://www.bilibili.com/video/BV12k4y1y75T?from=search&amp;seid=165729587306922938">https://www.bilibili.com/video/BV12k4y1y75T?from=search&amp;seid=165729587306922938</a></p>]]></content>
      
      
      <categories>
          
          <category> VueMastery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-element-admin权限控制理解</title>
      <link href="2021/02/08/vue-element-admin%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%90%86%E8%A7%A3/"/>
      <url>2021/02/08/vue-element-admin%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="如何共享状态"><a href="#如何共享状态" class="headerlink" title="如何共享状态"></a>如何共享状态</h3>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3使用技巧</title>
      <link href="2021/02/08/vue3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>2021/02/08/vue3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="如何共享状态"><a href="#如何共享状态" class="headerlink" title="如何共享状态"></a>如何共享状态</h3><ul><li>可以直接在一个JS文件内定义响应式变量，各组件分别引用，这样最简单，但是不支持SSR</li><li>使用provide/ inject插件的方式</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user.js</span></span><br><span class="line"><span class="comment">//首先需要实现数据处理逻辑</span></span><br><span class="line"><span class="keyword">const</span> userStore = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//这里可以使用vue3 的响应式</span></span><br><span class="line"><span class="keyword">const</span> userInfo = ref(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//通过接口获取到user的信息</span></span><br><span class="line">userInfo.value = userInfo_by_api;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 一些其他的方法</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="comment">//返回需要用到的属性</span></span><br><span class="line">  getUser(),</span><br><span class="line">  userInfo,</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来需要把方法以注入的形式暴露出来给需要的地方调用。</span></span><br><span class="line"><span class="comment">//需要给provide一个唯一的名称以免后面调用的时候冲突。</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">Symbol</span>() <span class="comment">//这里使用Symbol 新的一个数据类型，保证变量名唯一</span></span><br><span class="line"><span class="keyword">const</span> useUser = <span class="function">() =&gt;</span> inject(user) <span class="comment">//这里使用inject调用 provide注入的userStore的方法。</span></span><br><span class="line"><span class="comment">//把方法都export出去</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  user,</span><br><span class="line">  userStore</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useUser</span><br><span class="line"></span><br><span class="line"><span class="comment">//以插件的形式把所有的store都集合起来，然后provide注入。</span></span><br><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;user, userStore&#125; <span class="keyword">from</span> <span class="string">&quot;path/to/user.js&quot;</span></span><br><span class="line"><span class="keyword">const</span> store = &#123;</span><br><span class="line">  install: <span class="function">(<span class="params">app: App</span>) =&gt;</span> &#123;</span><br><span class="line">    app.provide(user, userStore());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后在main.js 中use</span></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;path/to/index.js&quot;</span></span><br><span class="line">......</span><br><span class="line">createApp(App).use(store)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后就可以在需要使用的地方使用了</span></span><br><span class="line"><span class="comment">//other_need_use.js</span></span><br><span class="line"><span class="keyword">import</span> useUser <span class="keyword">from</span> <span class="string">&quot;path/to/user.js&quot;</span></span><br><span class="line"><span class="keyword">const</span> user = useUser()</span><br><span class="line"><span class="comment">//可以通过user.xxx 访问user.js中的属性了。</span></span><br><span class="line"><span class="comment">//user.getUser() 等等。</span></span><br></pre></td></tr></table></figure><p>  以下是vueconf中分享的方法，原理跟上面是一样的<br>  <img src="/2021/02/08/vue3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/vue3.png" alt="vue3"></p>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue经典问题</title>
      <link href="2021/02/08/vue%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
      <url>2021/02/08/vue%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在此，我们详细分析一下几个vue经典问题：</p><h3 id="v-if和v-for哪个优先级高"><a href="#v-if和v-for哪个优先级高" class="headerlink" title="v-if和v-for哪个优先级高"></a>v-if和v-for哪个优先级高</h3><ul><li>v-for优先级高，如果v-for和v-if放在同一个元素上，则会先循环再判断条件，所以这导致每次渲染都会先渲染整个列表。</li><li>解决方法可以把v-if往上一层容器元素放，如果判断条件是列表渲染的内容，则应该用计算属性过滤下要循环的数组。<br>在源码compiler/codegen/index.js中，只要碰到一个元素，就会执行genElement函数<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export function genElement (el: ASTElement, <span class="keyword">state</span>: CodegenState): string &#123;</span><br><span class="line">  if (el.<span class="keyword">parent</span>) &#123;</span><br><span class="line">    el.pre = el.pre || el.<span class="keyword">parent</span>.pre</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;</span><br><span class="line">    return genStatic(el, <span class="keyword">state</span>)</span><br><span class="line">  &#125; else if (el.<span class="keyword">once</span> &amp;&amp; !el.<span class="keyword">once</span>Processed) &#123;</span><br><span class="line">    return genOnce(el, <span class="keyword">state</span>)</span><br><span class="line">  &#125; else if (el.<span class="keyword">for</span> &amp;&amp; !el.<span class="keyword">for</span>Processed) &#123;</span><br><span class="line">    return genFor(el, <span class="keyword">state</span>)  //<span class="keyword">for</span>在前面</span><br><span class="line">  &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">    return genIf(el, <span class="keyword">state</span>)  //if在后面</span><br><span class="line">  &#125; else if (el.<span class="keyword">tag</span> === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !<span class="keyword">state</span>.pre) &#123;</span><br><span class="line">    return genChildren(el, <span class="keyword">state</span>) || &#x27;void <span class="number">0</span>&#x27;</span><br><span class="line">  &#125; else if (el.<span class="keyword">tag</span> === &#x27;slot&#x27;) &#123;</span><br><span class="line">    return genSlot(el, <span class="keyword">state</span>)</span><br><span class="line">  &#125; else &#123;</span><br></pre></td></tr></table></figure></li></ul><h3 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h3><ul><li>key的作用为更高效的更新虚拟DOM。</li><li>vue在patch的过程中，判断两个节点是否是相同节点，key是一个必要条件，如果不定义key，vue会认为两个节点是相同节点，会强制更新，使得整个patch过程比较低效，影响性能。</li><li>实际渲染列表必须设置key，不要用数组下标，不然如果对这个数组进行元素删除，会串位。</li><li>从源码中可以知道，vue判断两个节点是否相同时主要判断两者的key和元素类型等，因此如果不设置key，它的值就是undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的。（问：两个节点相同需要更新，还是不同需要更新？）</li><li>patch的过程（patch就是diff），假设在ABCDE的BC中间插入一个F，如果没有定义key，则会做5次更新，1次新增操作，如果定义了key，则会头尾比较（如下），只需要执行一次新增操作。</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 第<span class="number">1</span>次循环patch A</span><br><span class="line">A B <span class="keyword">C</span> <span class="keyword">D</span> <span class="keyword">E</span></span><br><span class="line">A B F <span class="keyword">C</span> <span class="keyword">D</span> <span class="keyword">E</span></span><br><span class="line">// 第<span class="number">2</span>次循环patch B</span><br><span class="line">B <span class="keyword">C</span> <span class="keyword">D</span> <span class="keyword">E</span></span><br><span class="line">B F <span class="keyword">C</span> <span class="keyword">D</span> <span class="keyword">E</span></span><br><span class="line">// 第<span class="number">3</span>次循环patch <span class="keyword">E</span></span><br><span class="line"><span class="keyword">C</span> <span class="keyword">D</span> <span class="keyword">E</span></span><br><span class="line">F <span class="keyword">C</span> <span class="keyword">D</span> <span class="keyword">E</span></span><br><span class="line">// 第<span class="number">4</span>次循环patch <span class="keyword">D</span></span><br><span class="line"><span class="keyword">C</span> <span class="keyword">D</span></span><br><span class="line">F <span class="keyword">C</span> <span class="keyword">D</span></span><br><span class="line">// 第<span class="number">5</span>次循环patch <span class="keyword">C</span></span><br><span class="line"><span class="keyword">C</span></span><br><span class="line">F <span class="keyword">C</span></span><br><span class="line">// oldCh全部处理结束，newCh中剩下的F，创建F并插入到<span class="keyword">C</span>前面</span><br></pre></td></tr></table></figure><p>在源码中，src\core\vdom\patch.js - sameVnode()方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sameVnode (a, b) &#123;</span><br><span class="line">  return (</span><br><span class="line">    a.key<span class="operator"> === </span>b.key<span class="operator"> &amp;&amp; </span>(  <span class="comment">//先判断key，然后判断标签类别</span></span><br><span class="line">      (</span><br><span class="line">        a.tag<span class="operator"> === </span>b.tag &amp;&amp;</span><br><span class="line">        a.isComment<span class="operator"> === </span>b.isComment &amp;&amp;</span><br><span class="line">        is<span class="constructor">Def(<span class="params">a</span>.<span class="params">data</span>)</span><span class="operator"> === </span>is<span class="constructor">Def(<span class="params">b</span>.<span class="params">data</span>)</span> &amp;&amp;</span><br><span class="line">        same<span class="constructor">InputType(<span class="params">a</span>, <span class="params">b</span>)</span></span><br><span class="line">      )<span class="operator"> || </span>(</span><br><span class="line">        is<span class="constructor">True(<span class="params">a</span>.<span class="params">isAsyncPlaceholder</span>)</span> &amp;&amp;</span><br><span class="line">        a.asyncFactory<span class="operator"> === </span>b.asyncFactory &amp;&amp;</span><br><span class="line">        is<span class="constructor">Undef(<span class="params">b</span>.<span class="params">asyncFactory</span>.<span class="params">error</span>)</span></span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue在对比两组节点时用的首尾猜测，没有用双循环，节省很多性能。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; <span class="keyword">new</span><span class="type">StartIdx</span> &lt;= <span class="keyword">new</span><span class="type">EndIdx</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, <span class="keyword">new</span><span class="type">StartVnode</span>)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, <span class="keyword">new</span><span class="type">StartVnode</span>, insertedVnodeQueue, <span class="keyword">new</span><span class="type">Ch</span>, <span class="keyword">new</span><span class="type">StartIdx</span>)</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">    <span class="keyword">new</span><span class="type">StartVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[++<span class="keyword">new</span><span class="type">StartIdx</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, <span class="keyword">new</span><span class="type">EndVnode</span>)) &#123;</span><br><span class="line">    patchVnode(oldEndVnode, <span class="keyword">new</span><span class="type">EndVnode</span>, insertedVnodeQueue, <span class="keyword">new</span><span class="type">Ch</span>, <span class="keyword">new</span><span class="type">EndIdx</span>)</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    <span class="keyword">new</span><span class="type">EndVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[--<span class="keyword">new</span><span class="type">EndIdx</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, <span class="keyword">new</span><span class="type">EndVnode</span>)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">    patchVnode(oldStartVnode, <span class="keyword">new</span><span class="type">EndVnode</span>, insertedVnodeQueue, <span class="keyword">new</span><span class="type">Ch</span>, <span class="keyword">new</span><span class="type">EndIdx</span>)</span><br><span class="line">    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">    <span class="keyword">new</span><span class="type">EndVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[--<span class="keyword">new</span><span class="type">EndIdx</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, <span class="keyword">new</span><span class="type">StartVnode</span>)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">    patchVnode(oldEndVnode, <span class="keyword">new</span><span class="type">StartVnode</span>, insertedVnodeQueue, <span class="keyword">new</span><span class="type">Ch</span>, <span class="keyword">new</span><span class="type">StartIdx</span>)</span><br><span class="line">    canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    <span class="keyword">new</span><span class="type">StartVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[++<span class="keyword">new</span><span class="type">StartIdx</span>]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><h3 id="双向绑定以及它的实现原理"><a href="#双向绑定以及它的实现原理" class="headerlink" title="双向绑定以及它的实现原理"></a>双向绑定以及它的实现原理</h3><ul><li>双向绑定是指令v-model，v-model是语法糖，默认情况下相当于:value和@input</li><li>使用v-model可以减少大量繁琐的事件处理代码</li><li>v-model通常在原生表单里使用，在定义组件上如果要使用它需要在组件内绑定value并处理输入事件</li></ul><h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><ul><li>diff算法在vue里叫做patch，通过新旧虚拟DOM对比，将变化的地方转换为DOM操作</li><li>在vue2里，每个组件只有一个watcher，所以要精确找到变化发生的地方，所以要patch</li><li>组件数据变化时，对应的watcher会通知更新并执行更新函数，它会执行渲染函数获取全新虚拟DOM：newVnode,此时就会执行patch对比上次渲染的oldVnode，和新的渲染结果newVnode。</li><li>patch过程遵循深度优先、同层比较的策略，两个节点之间比较时，如果它们拥有子节点，会先比较子节点；比较两组子节点时，会假设头尾节点可能相同先做尝试，没有找到相同节点后才按照通用方式遍历查找；查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效。</li></ul><h3 id="vue中组件之间的通信方式？"><a href="#vue中组件之间的通信方式？" class="headerlink" title="vue中组件之间的通信方式？"></a>vue中组件之间的通信方式？</h3><ul><li>父子组件：props/ $emit / $on / ，$parent /  $children ，$attrs /  $listeners</li><li>跨层级：provide / inject ，eventbus，vuex，$root</li></ul><h3 id="简单说已说你对vuex理解"><a href="#简单说已说你对vuex理解" class="headerlink" title="简单说已说你对vuex理解"></a>简单说已说你对vuex理解</h3><ul><li>Vuex 是已个专为 Vue.js 应⽤程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li><li>我在使用vuex过程中有如下理解：先先是对核心概念的理解和运用，将全局状态放入state对象中，它本身一棵状态树，组件中使用store实例的state访问这些状态；然后有配套的mutation方法修改这些状态，并且只能用mutation修改状态，在组件中调用commit方法提交mutation；如果应用中有异步操作或者复杂逻辑组合，我们需要编写action，执⾏结束如果有状态修改仍然需要提交mutation，组件中调用这些action使用dispatch方法派发。最后是模块化，通过modules选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，如果子模块有设置namespace，那么在提交mutation和派发action时还需要额外的命名空间前缀。</li><li>vuex在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了vue的数据响应化特性实现的，它会利用Vue将state作为data对其进⾏响应化处理，从而使得这些状态发生变化时，能够导致组件重新渲染。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="2020/08/16/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
      <url>2020/08/16/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h3><p>防抖就是每触发一次事件，就重新刷新定时器，等定时器延迟走完，执行函数。<br>比如百度搜索输入框，每输入一个字符，就刷新定时器，直到用户不再输入，则执行查询方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 维护一个 timer</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取函数的作用域和变量</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用防抖函数的时候，一般先赋值给一个变量，执行一次，这样就形成了闭包，多次执行内层函数，timer也只会定义一次</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounceFn = debounce(click,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h3><p>节流是在一段时间内只允许函数执行一次<br>比如点击一个按钮，一段时间内多次点击，只触发一次<br>时间戳实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span>(now-prev&gt;=delay)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            prev = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;,delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>区别在于，使用时间戳实现的节流函数会在第一次触发事件时立即执行，以后每过 delay 秒之后才执行一次，并且最后一次触发事件不会被执行；而定时器实现的节流函数在第一次触发时不会执行，而是在 delay 秒之后才执行，当最后一次停止触发后，还会再执行一次函数。</p>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写深拷贝</title>
      <link href="2020/08/13/%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>2020/08/13/%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="JSON-parse-JSON-stringify-obj"><a href="#JSON-parse-JSON-stringify-obj" class="headerlink" title="JSON.parse(JSON.stringify(obj))"></a>JSON.parse(JSON.stringify(obj))</h3><p>可实现多维对象的深拷贝，但会忽略undefined、任意的函数、symbol值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">obj1</span> <span class="string">=</span> &#123;</span><br><span class="line">    <span class="attr">x:</span> <span class="number">1</span>, </span><br><span class="line">    <span class="attr">y:</span> &#123;</span><br><span class="line">        <span class="attr">m:</span> <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">a:undefined</span>,</span><br><span class="line">    <span class="string">b:function(a</span>,<span class="string">b)</span>&#123;</span><br><span class="line">      <span class="string">return</span> <span class="string">a+b</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">c:Symbol(&quot;foo&quot;)</span></span><br><span class="line">&#125;<span class="string">;</span></span><br><span class="line"><span class="string">var</span> <span class="string">obj2</span> <span class="string">=</span> <span class="string">JSON.parse(JSON.stringify(obj1));</span></span><br><span class="line"><span class="string">console.log(obj1)</span> <span class="string">//&#123;x:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">y:</span> &#123;<span class="attr">m:</span> <span class="number">1</span>&#125;<span class="string">,</span> <span class="attr">a:</span> <span class="string">undefined,</span> <span class="attr">b:</span> <span class="string">ƒ,</span> <span class="attr">c:</span> <span class="string">Symbol(foo)&#125;</span></span><br><span class="line"><span class="string">console.log(obj2)</span> <span class="string">//&#123;x:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">y:</span> &#123;<span class="attr">m:</span> <span class="number">1</span>&#125;<span class="string">&#125;</span></span><br><span class="line"><span class="string">obj2.y.m</span> <span class="string">=</span> <span class="number">2</span><span class="string">;</span> <span class="string">//修改obj2.y.m</span></span><br><span class="line"><span class="string">console.log(obj1)</span> <span class="string">//&#123;x:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">y:</span> &#123;<span class="attr">m:</span> <span class="number">1</span>&#125;<span class="string">,</span> <span class="attr">a:</span> <span class="string">undefined,</span> <span class="attr">b:</span> <span class="string">ƒ,</span> <span class="attr">c:</span> <span class="string">Symbol(foo)&#125;</span></span><br><span class="line"><span class="string">console.log(obj2)</span> <span class="string">//&#123;x:</span> <span class="number">2</span><span class="string">,</span> <span class="attr">y:</span> &#123;<span class="attr">m:</span> <span class="number">2</span>&#125;<span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>注：进行JSON.stringify()序列化的过程中，undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。</p><h3 id="深拷贝函数简单写法（递归实现）（乞丐版）"><a href="#深拷贝函数简单写法（递归实现）（乞丐版）" class="headerlink" title="深拷贝函数简单写法（递归实现）（乞丐版）"></a>深拷贝函数简单写法（递归实现）（乞丐版）</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> deep<span class="constructor">Clone(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//判断返回对象或者数组,因为typeof不能区别数组与对象</span></span><br><span class="line">    var result = <span class="module-access"><span class="module"><span class="identifier">Array</span>.</span></span>is<span class="constructor">Array(<span class="params">obj</span>)</span> ? <span class="literal">[]</span> : &#123;&#125;  </span><br><span class="line">    <span class="comment">//判断是否是对象</span></span><br><span class="line">    <span class="keyword">if</span> (obj<span class="operator"> &amp;&amp; </span>typeof obj<span class="operator"> === </span>&#x27;<span class="keyword">object</span>&#x27;) &#123; </span><br><span class="line">        <span class="comment">//便利每个键名</span></span><br><span class="line">        <span class="keyword">for</span> (var key <span class="keyword">in</span> obj) &#123;              </span><br><span class="line">            <span class="comment">//筛选出对象自带属性 </span></span><br><span class="line">            <span class="keyword">if</span> (obj.has<span class="constructor">OwnProperty(<span class="params">key</span>)</span>) &#123;      </span><br><span class="line">                <span class="comment">//如果某个属性已然为对象</span></span><br><span class="line">                <span class="keyword">if</span> (obj<span class="literal">[<span class="identifier">key</span>]</span><span class="operator"> &amp;&amp; </span>typeof obj<span class="literal">[<span class="identifier">key</span>]</span><span class="operator"> === </span>&#x27;<span class="keyword">object</span>&#x27;) &#123;   </span><br><span class="line">                    <span class="comment">//则递归此函数</span></span><br><span class="line">                    result<span class="literal">[<span class="identifier">key</span>]</span> = deep<span class="constructor">Clone(<span class="params">obj</span>[<span class="params">key</span>])</span>       </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则直接赋值</span></span><br><span class="line">                    result<span class="literal">[<span class="identifier">key</span>]</span> = obj<span class="literal">[<span class="identifier">key</span>]</span>              </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result  <span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝函数改进（防止循环递归）（够用版）"><a href="#深拷贝函数改进（防止循环递归）（够用版）" class="headerlink" title="深拷贝函数改进（防止循环递归）（够用版）"></a>深拷贝函数改进（防止循环递归）（够用版）</h3><p>解决因循环递归而暴栈的问题，只需要判断一个对象的字段是否引用了这个对象或这个对象的任意父级即可。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, parent = null</span>)</span>&#123; <span class="comment">// 改进（1）</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Array</span>.isArray(obj)?[]:&#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> _parent = <span class="built_in">parent</span>;  <span class="comment">// 改进（2）</span></span><br><span class="line">  <span class="keyword">while</span>(_parent)&#123; <span class="comment">// 改进（3）</span></span><br><span class="line">    <span class="keyword">if</span>(_parent.originalParent === obj)&#123;</span><br><span class="line">      <span class="keyword">return</span> _parent.currentParent;</span><br><span class="line">    &#125;</span><br><span class="line">    _parent = _parent.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">          result[key] = deepClone(obj[key],&#123; <span class="comment">// 改进（4）</span></span><br><span class="line">            <span class="attribute">originalParent</span>: obj,</span><br><span class="line">            <span class="attribute">currentParent</span>: result,</span><br><span class="line">            <span class="attribute">parent</span>: <span class="built_in">parent</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;<span class="title">else</span>&#123;</span><br><span class="line">          result[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试用</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attribute">x</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="attribute">y</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">obj1.z = obj1;</span><br><span class="line"><span class="keyword">var</span> obj2 = deepClone(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//太长了去浏览器试一下吧～ </span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//太长了去浏览器试一下吧～</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝函数最终版（支持基本数据类型、原型链、RegExp、Date类型）（至尊版）"><a href="#深拷贝函数最终版（支持基本数据类型、原型链、RegExp、Date类型）（至尊版）" class="headerlink" title="深拷贝函数最终版（支持基本数据类型、原型链、RegExp、Date类型）（至尊版）"></a>深拷贝函数最终版（支持基本数据类型、原型链、RegExp、Date类型）（至尊版）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, parent = null</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">let</span> result; <span class="comment">// 最后的返回结果</span></span><br><span class="line">  <span class="keyword">let</span> _parent = parent; <span class="comment">// 防止循环引用</span></span><br><span class="line">  <span class="keyword">while</span>(_parent)&#123;</span><br><span class="line">    <span class="keyword">if</span>(_parent.originalParent === obj)&#123;</span><br><span class="line">      <span class="keyword">return</span> _parent.currentParent;</span><br><span class="line">    &#125;</span><br><span class="line">    _parent = _parent.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>)&#123; <span class="comment">// 返回引用数据类型(null已被判断条件排除))</span></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>)&#123; <span class="comment">// RegExp类型</span></span><br><span class="line">      result = <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj.source, obj.flags)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>)&#123; <span class="comment">// Date类型</span></span><br><span class="line">      result = <span class="keyword">new</span> <span class="built_in">Date</span>(obj.getTime());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123; <span class="comment">// Array类型</span></span><br><span class="line">        result = []</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">// Object类型，继承原型链</span></span><br><span class="line">        <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">        result = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123; <span class="comment">// Array类型 与 Object类型 的深拷贝</span></span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">          <span class="keyword">if</span>(obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">            result[key] = deepClone(obj[key],&#123; </span><br><span class="line">              originalParent: obj,</span><br><span class="line">              currentParent: result,</span><br><span class="line">              parent: parent</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[key] = obj[key];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123; <span class="comment">// 返回基本数据类型与Function类型,因为Function不需要深拷贝</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="2020/07/28/%E9%97%AD%E5%8C%85/"/>
      <url>2020/07/28/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><pre><code>闭包是指在 JavaScript 中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，</code></pre><p>即使在其外部函数被返回return掉（寿命终结）了之后。<br>闭包是在函数里面定义一个函数，该函数可以是匿名函数，该子函数能够读写父函数的局部变量。</p><h3 id="闭包的常见案例分析"><a href="#闭包的常见案例分析" class="headerlink" title="闭包的常见案例分析"></a>闭包的常见案例分析</h3><h4 id="案例1—基本介绍："><a href="#案例1—基本介绍：" class="headerlink" title="案例1—基本介绍："></a>案例1—基本介绍：</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> localVal=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> localVal;</span><br><span class="line">&#125;</span><br><span class="line">A();<span class="comment">//输出10</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> localVal=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(localVal);</span><br><span class="line">         <span class="keyword">return</span> localVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func=A();</span><br><span class="line">func();<span class="comment">//输出10</span></span><br></pre></td></tr></table></figure><p>两段代码，在第二段代码中，函数A内的匿名函数可以访问到函数A中的局部变量这就是闭包的基本使用。</p><h4 id="案例2—前端实现点击事件"><a href="#案例2—前端实现点击事件" class="headerlink" title="案例2—前端实现点击事件"></a>案例2—前端实现点击事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> localData=<span class="string">&quot;localData here&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(localData);    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>前端原始点击事件操作也用到了闭包来访问外部的局部变量。</p><h4 id="案例3—ajax请求"><a href="#案例3—ajax请求" class="headerlink" title="案例3—ajax请求"></a>案例3—ajax请求</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> localData=<span class="string">&quot;localData here&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> url=<span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url:url,</span><br><span class="line">      success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="comment">//do sth...</span></span><br><span class="line">          <span class="built_in">console</span>.log(localData);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>在ajax请求的方法中也用到了闭包，访问外部的局部变量。</p><h4 id="案例4—for循环案例"><a href="#案例4—for循环案例" class="headerlink" title="案例4—for循环案例"></a>案例4—for循环案例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrays = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    arrays.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;&gt;&gt;&gt; &#x27;</span> + i); <span class="comment">//all are 3</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码，刚看了代码一定会以为陆续打印出1，2，3，实际输出的是3，3，3，出现这种情况的原因是匿名函数保存的是引用，当for循环结束的时候，i已经变成3了，所以打印的时候变成3。出现这种情况的解决办法是利用闭包解决问题。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="name">var</span> i=0<span class="comment">; i&lt;3; i++) &#123;</span></span><br><span class="line">    (<span class="name">function</span>(<span class="name">n</span>) &#123;</span><br><span class="line">        tasks.push(<span class="name">function</span>() &#123;</span><br><span class="line">            console.log(&#x27;&gt;&gt;&gt; &#x27; + n)<span class="comment">;</span></span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;)(<span class="name">i</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包里的匿名函数，读取变量的顺序，先读取本地变量，再读取父函数的局部变量，如果找不到到全局里面搜索，i作为局部变量存到闭包里面，所以调整后的代码可以能正常打印1，2，3。</p><h3 id="闭包与内存泄漏"><a href="#闭包与内存泄漏" class="headerlink" title="闭包与内存泄漏"></a>闭包与内存泄漏</h3><p>javascript回收后内存的方式:<br>javascript的主要通过计数器方式回收内存，假设有a，b，c三个对象，当a引用b的时候，那么b的引用计算器增加1(通俗的说用到那个对象哪个对象引用计算器增加1)，同时b引用c的时候，c引用计数器增加1，当a被释放的时候，b的引用计数器减少1，变成0的时候这个对象被释放，c计数器变成0，被释放,但是当遇到b和c之间互相引用的时候，无法通过计数器方式释放内存。</p><p>闭包可以导致上面所说b和c互相引用无法释放内存 第一个案例的代码拿过来分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> localVal=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(localVal);</span><br><span class="line">         <span class="keyword">return</span> localVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func=A();</span><br><span class="line">func();<span class="comment">//输出10</span></span><br></pre></td></tr></table></figure><p>当A函数结束的时候，想要释放，发现它的localVal变量被匿名函数引用，所有A函数无法释放，导致内存泄漏。但是也有好处，闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p><p>说明:闭包不代表一定会带来内存泄漏，良好的使用闭包是不会造成内存泄漏的。</p><h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><p>封装</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="comment">//变量作用域为函数内部，外部无法访问    </span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;default&quot;</span>;       </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">       getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">           <span class="keyword">return</span> name;    </span><br><span class="line">       &#125;,    </span><br><span class="line">       setName : <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;    </span><br><span class="line">           name = newName;    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;();    </span><br><span class="line">     </span><br><span class="line"><span class="keyword">print</span>(person.name);<span class="comment">//直接访问，结果为undefined    </span></span><br><span class="line"><span class="keyword">print</span>(person.getName());    </span><br><span class="line">person.setName(<span class="string">&quot;kaola&quot;</span>);    </span><br><span class="line"><span class="keyword">print</span>(person.getName());    </span><br><span class="line">   </span><br><span class="line">得到结果如下：  </span><br><span class="line">   </span><br><span class="line">undefined  </span><br><span class="line"><span class="keyword">default</span>  </span><br><span class="line">kaola</span><br></pre></td></tr></table></figure><p>实例中的for循环另一种形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">doucument.body.innerHTML=<span class="string">&quot;&lt;div id=div1&gt;aaa&lt;/div&gt;&quot;</span>+<span class="string">&quot;&lt;div id=div2&gt;bbb&lt;/div&gt;&quot;</span>+<span class="string">&quot;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    !<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div&#x27;</span>+i);</span><br><span class="line">        addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           alert(i);<span class="comment">//1,2,3 </span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果缓存</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CachedSearchBox = (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;,    </span><br><span class="line">       count = [];    </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">       attachSearchBox : <span class="function"><span class="keyword">function</span><span class="params">(dsid)</span></span>&#123;    </span><br><span class="line">           <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;<span class="comment">//如果结果在缓存中    </span></span><br><span class="line">              <span class="keyword">return</span> cache[dsid];<span class="comment">//直接返回缓存中的对象    </span></span><br><span class="line">           &#125;    </span><br><span class="line">           <span class="keyword">var</span> fsb = <span class="keyword">new</span> uikit.webctrl.SearchBox(dsid);<span class="comment">//新建    </span></span><br><span class="line">           cache[dsid] = fsb;<span class="comment">//更新缓存    </span></span><br><span class="line">           <span class="keyword">if</span>(count.length &gt; <span class="number">100</span>)&#123;<span class="comment">//保正缓存的大小&lt;=100    </span></span><br><span class="line">              <span class="keyword">delete</span> cache[count.shift()];    </span><br><span class="line">           &#125;    </span><br><span class="line">           <span class="keyword">return</span> fsb;          </span><br><span class="line">       &#125;,    </span><br><span class="line">     </span><br><span class="line">       clearSearchBox : <span class="function"><span class="keyword">function</span><span class="params">(dsid)</span></span>&#123;    </span><br><span class="line">           <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;    </span><br><span class="line">              cache[dsid].clearSelection();      </span><br><span class="line">           &#125;    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;)();    </span><br><span class="line">     </span><br><span class="line">CachedSearchBox.attachSearchBox(<span class="string">&quot;input&quot;</span>);</span><br></pre></td></tr></table></figure><p>说明：开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p><h3 id="面试题分析"><a href="#面试题分析" class="headerlink" title="面试题分析"></a>面试题分析</h3><p>闭包测试题: 求输出结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">(n,o)</span></span>&#123;</span><br><span class="line">    console.log(o);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span>:<span class="title">function</span><span class="params">(m)</span></span>&#123;<span class="comment">//[2]</span></span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">(m,n)</span></span>;<span class="comment">//[1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a=<span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">a.<span class="keyword">fun</span>(<span class="number">1</span>);</span><br><span class="line">a.<span class="keyword">fun</span>(<span class="number">2</span>);</span><br><span class="line">a.<span class="keyword">fun</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> b=<span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>.<span class="keyword">fun</span>(<span class="number">1</span>).<span class="keyword">fun</span>(<span class="number">2</span>).<span class="keyword">fun</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> c=<span class="function"><span class="title">fun</span><span class="params">(<span class="number">0</span>)</span></span>.<span class="keyword">fun</span>(<span class="number">1</span>);</span><br><span class="line">c.<span class="keyword">fun</span>(<span class="number">2</span>);</span><br><span class="line">c.<span class="keyword">fun</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>注意点:<br>JS的词法作用域,JS变量作用域存在于函数体中即函数体，并且变量的作用域是在函数定义声明的时候就是确定的，而非在函数运行时。<br>在JS中调用函数的时候，如果用一个参数的方法调用两个参数的方法，这时候只是第二个参数未定义，代码不会报错停止运行，正常流程往下走，像面试题中仍然会返回一个对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.闭包其实是在函数内部定义一个函数。<br>2.闭包在使用的时候不会释放外部的引用，闭包函数内部的值会得到保留。<br>3.闭包里面的匿名函数，读取变量的顺序，先读取本地变量，再读取父函数的局部变量。<br>4.对于闭包外部无法引用它内部的变量，因此在函数内部创建的变量执行完后会立刻释放资源，<br>不污染全局对象。<br>5.闭包使用的时候要考虑到内存泄漏，因为不释放外部引用，但是合理的使用闭包是内存使用不是内存泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue小技巧</title>
      <link href="2020/07/25/vue%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>2020/07/25/vue%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="如何获取组件渲染后的DOM"><a href="#如何获取组件渲染后的DOM" class="headerlink" title="如何获取组件渲染后的DOM"></a>如何获取组件渲染后的DOM</h3><p>如果直接用ref获取组件，则只能得到vue组件，所以使用$el属性就可以选取DOM</p><p>模板上定义ref</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">ref</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS用ref获取，然后用$el选择</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(this.<span class="variable">$refs</span>.<span class="keyword">test</span>.<span class="variable">$el</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大文件上传</title>
      <link href="2020/07/24/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A6%81%E7%82%B9/"/>
      <url>2020/07/24/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ol><li><p>先建立一个最简单的input</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">input</span> <span class="built_in">type</span>=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> @change=<span class="string">&quot;handleFilerChange&quot;</span>&gt;</span><br><span class="line">//监听<span class="keyword">change</span>事件，拿到<span class="keyword">file</span></span><br><span class="line">const [<span class="keyword">file</span>] =<span class="keyword">e</span>.target.<span class="keyword">files</span></span><br></pre></td></tr></table></figure></li><li><p>上传文件请求，同时实现进度条</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个formData</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">form</span> = new formData()</span><br><span class="line"><span class="keyword">form</span>.<span class="keyword">append</span>(&#x27;name&#x27;,&#x27;<span class="keyword">file</span>&#x27;)</span><br><span class="line"><span class="keyword">form</span>.<span class="keyword">append</span>(&#x27;<span class="keyword">file</span>&#x27;,this.<span class="keyword">file</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">ret</span> = await this.<span class="variable">$http</span>.<span class="keyword">post</span>(&#x27;/uploadfile&#x27;,<span class="keyword">form</span>,&#123;</span><br><span class="line">    <span class="comment">//请求进度计算</span></span><br><span class="line">  onUploadProgress:progress=&gt;&#123;</span><br><span class="line">  this.uploadProgress = Number(((progress.load/progress.<span class="keyword">total</span>)*100).toFixed(2))  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>文件检验e</p></li></ol><ul><li>将文件流变为16进制的ACSII码，同一类文件有固定特征（头，尾为固定的几位数）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">blobToString(blob)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//FileReader是异步执行的，onload是其成功的回调函数</span></span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">    reader.onload= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// console.log(reader.result.split(&#x27;&#x27;).map(v=v.charCodeAt()))</span></span><br><span class="line">      <span class="keyword">const</span> ret = reader.result.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                  .map(<span class="function"><span class="params">v</span>=&gt;</span>v.charCodeAt())</span><br><span class="line">                  .map(<span class="function"><span class="params">v</span>=&gt;</span>v.toString(<span class="number">16</span>).toUpperCase())</span><br><span class="line">                  .join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      resolve (ret)</span><br><span class="line">    &#125;</span><br><span class="line">    reader.readAsBinaryString(blob)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组方法总结(新增)</title>
      <link href="2020/04/22/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93(%E6%96%B0%E5%A2%9E)%20copy/"/>
      <url>2020/04/22/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93(%E6%96%B0%E5%A2%9E)%20copy/</url>
      
        <content type="html"><![CDATA[<h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>方法是用于类似数组的对象（即有length属性的对象）和可遍历对象转为真正的数组。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let <span class="type">json</span> =&#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;卢&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;本&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>:<span class="string">&#x27;伟&#x27;</span>,</span><br><span class="line">    length:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">let arr = <span class="keyword">Array</span>.<span class="keyword">from</span>(<span class="type">json</span>);</span><br><span class="line">console.log(arr); // [&quot;卢&quot;, &quot;本&quot;, &quot;伟&quot;]</span><br></pre></td></tr></table></figure><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p>方法是将一组值转变为数组，参数不分类型，只分数量，数量为0返回空数组。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let</span> arr<span class="number">1</span> = Array.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="attribute">let</span> arr<span class="number">2</span> = Array.of([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="attribute">let</span> arr<span class="number">3</span> = Array.of(undefined);</span><br><span class="line"><span class="attribute">let</span> arr<span class="number">4</span> = Array.of();</span><br><span class="line"><span class="attribute">console</span>.log(arr<span class="number">1</span>); //<span class="meta"> [1, 2, 3]</span></span><br><span class="line"><span class="attribute">console</span>.log(arr<span class="number">2</span>); //<span class="meta"> [[1, 2, 3]]</span></span><br><span class="line"><span class="attribute">console</span>.log(arr<span class="number">3</span>); //<span class="meta"> [undefined]</span></span><br><span class="line"><span class="attribute">console</span>.log(arr<span class="number">4</span>); //<span class="meta"> []</span></span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>方法返回通过测试（函数内判断）的数组的第一个元素的值。方法为数组中的每个元素都调用一次函数执行。当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。</p><p>回调函数可以接收3个参数，依次为当前的值（currentValue）、当前的位置（index）、原数组（arr）</p><p>注意：find() 对于空数组，函数是不会执行的。find() 并没有改变数组的原始值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> result1 = Arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> currentValue&gt;<span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> result2 = Arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> currentValue&gt;<span class="number">9</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(result2); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>find()实现根据id取出数组中的对象</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Arr = [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">id:</span><span class="string">1,</span></span><br><span class="line"><span class="string">name</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">id:</span><span class="string">2,</span></span><br><span class="line"><span class="string">name</span>:<span class="string">&quot;李四&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> obj = Arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue,index,arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> currentValue.id===<span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><p>findIndex和find差不多，不过默认返回的是索引，如果没有符合条件的元素返回 -1</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Arr = <span class="literal">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>]</span>;</span><br><span class="line"><span class="keyword">let</span> result1 = <span class="module-access"><span class="module"><span class="identifier">Arr</span>.</span></span>find<span class="constructor">Index(<span class="params">function</span>(<span class="params">currentValue</span>,<span class="params">index</span>,<span class="params">arr</span>)</span>&#123;</span><br><span class="line">return currentValue&gt;<span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="module-access"><span class="module"><span class="identifier">Arr</span>.</span></span>find<span class="constructor">Index(<span class="params">function</span>(<span class="params">currentValue</span>,<span class="params">index</span>,<span class="params">arr</span>)</span>&#123;</span><br><span class="line">return currentValue&gt;<span class="number">9</span>;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(result1); <span class="comment">// 3</span></span><br><span class="line">console.log(result2); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h3 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h3><p>fill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p><p>语法：array.fill(value, start, end)<br>value：必需。填充的值。<br>start：可选。开始填充位置。如果这个参数是负数，那么它规定的是从数组尾部开始算起。<br>end：可选。停止填充位置 (默认为 array.length)。如果这个参数是负数，那么它规定的是从数组尾部开始算起。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">arr</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="string">;</span></span><br><span class="line"><span class="string">arr.fill(0);</span>  <span class="string">//</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="string">arr.fill(0,1);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] </span><br><span class="line"><span class="string">arr.fill(0,1,2);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="string">arr.fill(0,-1);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>]</span><br><span class="line"><span class="string">arr.fill(0,1,-1);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h3 id="遍历数组方法-keys-、values-、entries"><a href="#遍历数组方法-keys-、values-、entries" class="headerlink" title="遍历数组方法 keys()、values()、entries()"></a>遍历数组方法 keys()、values()、entries()</h3><p>这三个方法都是返回一个遍历器对象，可用for…of循环遍历，唯一区别：keys()是对键名的遍历、values()对键值的遍历、entries()是对键值对的遍历。</p><h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="keyword">for</span>(let i of arr.keys())&#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="regexp">//</span>打印：</span><br><span class="line">   <span class="regexp">//</span> <span class="number">0</span></span><br><span class="line">   <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">   <span class="regexp">//</span> <span class="number">2</span></span><br><span class="line">   <span class="regexp">//</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="keyword">for</span>(let i of arr.values())&#123;</span><br><span class="line">console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="regexp">//</span>打印：</span><br><span class="line">   <span class="regexp">//</span> a</span><br><span class="line">   <span class="regexp">//</span> b</span><br><span class="line">   <span class="regexp">//</span> c</span><br><span class="line">   <span class="regexp">//</span> d</span><br></pre></td></tr></table></figure><h4 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="keyword">for</span>(let i of arr.entries())&#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span>打印：</span><br><span class="line"><span class="regexp">//</span> [<span class="number">0</span>, <span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="regexp">//</span> [<span class="number">1</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line"><span class="regexp">//</span> [<span class="number">2</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line"><span class="regexp">//</span> [<span class="number">3</span>, <span class="string">&quot;d&quot;</span>]</span><br><span class="line"><span class="keyword">for</span>(let [idx,item] of arr.entries())&#123;</span><br><span class="line">    console.log(idx+<span class="string">&quot;:&quot;</span>+item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span>打印：</span><br><span class="line"><span class="regexp">//</span> <span class="number">0</span>:a</span><br><span class="line"><span class="regexp">//</span> <span class="number">1</span>:b</span><br><span class="line"><span class="regexp">//</span> <span class="number">2</span>:c</span><br><span class="line"><span class="regexp">//</span> <span class="number">3</span>:d</span><br></pre></td></tr></table></figure><h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。</p><p>语法：arr.includes(searchElement , fromIndex)<br>searchElement ： 必须。需要查找的元素值。<br>fromIndex：可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> result1 = arr.includes(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> result2 = arr.includes(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> result3 = arr.includes(<span class="string">&quot;b&quot;</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">let</span> result4 = arr.includes(<span class="string">&quot;b&quot;</span>,<span class="number">-3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(result2);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(result3);  <span class="comment">// flase</span></span><br><span class="line"><span class="built_in">console</span>.log(result4);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>从上面代码我们可以看出，当我们不给函数传递迭代初始值时初始值 total 为数组第一项，函数从数组第二项开始迭代；若我们给函数传递迭代初始值，则函数从数组第一项开始迭代。</p><h3 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h3><p>方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中，会覆盖原有成员</p><p>语法：array.copyWithin(target , start , end)<br>target ：必需。从该位置开始替换数据。<br>start ：可选。从该位置开始读取数据，默认为 0 。如果为负值，表示倒数。<br>end： 可选。到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">arr</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="string">;</span></span><br><span class="line"><span class="string">let</span> <span class="string">result1</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="string">.copyWithin(0);</span></span><br><span class="line"><span class="string">let</span> <span class="string">result2</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="string">.copyWithin(0,1);</span></span><br><span class="line"><span class="string">let</span> <span class="string">result3</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="string">.copyWithin(1,3,5);</span></span><br><span class="line"><span class="string">let</span> <span class="string">result4</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="string">.copyWithin(1,2,-1);</span></span><br><span class="line"><span class="string">let</span> <span class="string">result5</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="string">.copyWithin(1,-4,6);</span></span><br><span class="line"><span class="string">console.log(result1);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="string">console.log(result2);</span>  <span class="string">//</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br><span class="line"><span class="string">console.log(result3);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="string">console.log(result4);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="string">console.log(result5);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>原文：<a href="https://blog.csdn.net/qq_39132756/article/details/85007082">https://blog.csdn.net/qq_39132756/article/details/85007082</a></p>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组方法总结(进阶)</title>
      <link href="2020/04/20/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93(%E8%BF%9B%E9%98%B6)/"/>
      <url>2020/04/20/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93(%E8%BF%9B%E9%98%B6)/</url>
      
        <content type="html"><![CDATA[<h3 id="2个索引方法：indexOf-和-lastIndexOf"><a href="#2个索引方法：indexOf-和-lastIndexOf" class="headerlink" title="2个索引方法：indexOf()和 lastIndexOf()"></a>2个索引方法：indexOf()和 lastIndexOf()</h3><p>两个方法都返回要查找的项在数组中首次出现的位置，在没找到的情况下返回-1</p><p>indexOf()——–array.indexOf(item,start) （从数组的开头（位置 0）开始向后查找）<br>item： 必须。查找的元素。<br>start：可选的整数参数。规定在数组中开始检索的位置。如省略该参数，则将从array[0]开始检索。<br>lastIndexOf()——–array.lastIndexOf(item,start) （从数组的末尾开始向前查找）<br>item： 必须。查找的元素。<br>start：可选的整数参数。规定在数组中开始检索的位置。如省略该参数，则将从 array[array.length-1]开始检索。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">18</span>,<span class="number">7</span>,<span class="number">26</span>];</span><br><span class="line">console.log(arr.indexOf(<span class="number">7</span>));        <span class="comment">// 2</span></span><br><span class="line">console.log(arr.lastIndexOf(<span class="number">7</span>));    <span class="comment">// 6</span></span><br><span class="line">console.log(arr.indexOf(<span class="number">7</span>,<span class="number">4</span>));      <span class="comment">// 4</span></span><br><span class="line">console.log(arr.lastIndexOf(<span class="number">7</span>,<span class="number">2</span>));  <span class="comment">// 2</span></span><br><span class="line">console.log(arr.indexOf(<span class="number">5</span>));        <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h3 id="5个迭代方法：forEach-、map-、filter-、some-、every"><a href="#5个迭代方法：forEach-、map-、filter-、some-、every" class="headerlink" title="5个迭代方法：forEach()、map()、filter()、some()、every()"></a>5个迭代方法：forEach()、map()、filter()、some()、every()</h3><p>这几个方法语法都一样，都不会改变原数组。</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>对数组进行遍历循环，这个方法没有返回值。jquery()也提供了相应的方法each()方法。</p><p>语法：array.forEach(function(currentValue , index , arr){//do something}, thisValue)<br>currentValue : 必需。当前元素<br>index： 可选。当前元素的索引值。<br>arr : 可选。当前元素所属的数组对象。<br>thisValue： 可选。传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Arr = <span class="literal">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>]</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Arr</span>.</span></span><span class="keyword">for</span><span class="constructor">Each(<span class="params">function</span>(<span class="params">currentValue</span>, <span class="params">index</span>, <span class="params">arr</span>)</span>&#123;</span><br><span class="line">console.log(index+<span class="string">&quot;--&quot;</span>+currentValue+<span class="string">&quot;--&quot;</span>+(arr<span class="operator"> === </span>Arr));</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0--1--true</span></span><br><span class="line"><span class="comment">// 1--4--true</span></span><br><span class="line"><span class="comment">// 2--7--true</span></span><br><span class="line"><span class="comment">// 3--10--true</span></span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>指“映射”，方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><p>语法：array.map(function(currentValue , index , arr){//do something}, thisValue)</p><p>map方法实现数组中每个数求平方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue*currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// [1, 16, 64, 100]</span></span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>“过滤”功能，方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。和filter() 方法类似，jquery中有个 grep()方法也用于数组元素过滤筛选。</p><p>语法： array.filter(function(currentValue , index , arr){//do something}, thisValue)</p><p>filter方法实现筛选排除掉所有小于5的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> result1 = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue&gt;<span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result1);  <span class="comment">// [6, 8, 10]</span></span><br><span class="line"><span class="keyword">var</span> result2 = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue&gt;<span class="string">&quot;5&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result2);  <span class="comment">// [6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>当我们分别设置item &gt; 5和item &gt; “5”时, 返回的结果是一样的，由此我们可以看出函数支持弱等于（==），不是必须全（===）。</p><h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><p>判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</p><p>语法： array.every(function(currentValue , index , arr){//do something}, thisValue)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> result1 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue&lt; <span class="number">12</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result1);  <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> result2 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue&gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p>判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p><p>语法： array.some(function(currentValue , index , arr){//do something}, thisValue)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> result1 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue&gt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result1);  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> result2 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue&gt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result2);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="2个归并方法：reduce-、reduceRight"><a href="#2个归并方法：reduce-、reduceRight" class="headerlink" title="2个归并方法：reduce()、reduceRight()"></a>2个归并方法：reduce()、reduceRight()</h3><p>这两个方法都会迭代数组中的所有项，然后生成一个最终返回值。他们都接收两个参数，第一个参数是每一项调用的函数，函数接受四个参数分别是初始值，当前值，索引值，和当前数组，函数需要返回一个值，这个值会在下一次迭代中作为初始值。第二个参数是迭代初始值，参数可选，如果缺省，初始值为数组第一项，从数组第一个项开始叠加，缺省参数要比正常传值少一次运算。</p><p>reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p><p>reduce()语法：arr.reduce(function(total , cur , index , arr){//do something}, initialValue)<br>reduceRight()语法：arr.reduceRight(function(total , cur , index , arr){//do something}, initialValue)<br>total ：必需。初始值, 或者计算结束后的返回值。<br>cur ：必需。当前元素。<br>index ：可选。当前元素的索引。<br>arr：可选。当前元素所属的数组对象。<br>initialValue：可选。传递给函数的初始值。</p><p>下面代码实现数组求和：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">var result1 = arr.reduce(<span class="keyword">function</span>(total,cur,index,arr)&#123;</span><br><span class="line">console.log(<span class="string">&quot;total:&quot;</span>+total+<span class="string">&quot;,cur:&quot;</span>+cur+<span class="string">&quot;,index:&quot;</span>+index);</span><br><span class="line">    return total+cur;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(<span class="string">&quot;结果：&quot;</span>+result1);</span><br><span class="line"><span class="regexp">//</span> 输出</span><br><span class="line"><span class="regexp">//</span> total:<span class="number">1</span>,cur:<span class="number">2</span>,index:<span class="number">1</span></span><br><span class="line"><span class="regexp">//</span> total:<span class="number">3</span>,cur:<span class="number">3</span>,index:<span class="number">2</span></span><br><span class="line"><span class="regexp">//</span> total:<span class="number">6</span>,cur:<span class="number">4</span>,index:<span class="number">3</span></span><br><span class="line"><span class="regexp">//</span> total:<span class="number">10</span>,cur:<span class="number">5</span>,index:<span class="number">4</span></span><br><span class="line"><span class="regexp">//</span> 结果：<span class="number">15</span></span><br><span class="line">var result2 = arr.reduce(<span class="keyword">function</span>(total,cur,index,arr)&#123;</span><br><span class="line">console.log(<span class="string">&quot;total:&quot;</span>+total+<span class="string">&quot;,cur:&quot;</span>+cur+<span class="string">&quot;,index:&quot;</span>+index);</span><br><span class="line">    return total+cur;</span><br><span class="line">&#125;,<span class="number">10</span>);</span><br><span class="line">console.log(<span class="string">&quot;结果：&quot;</span>+result2);</span><br><span class="line"><span class="regexp">//</span> 输出</span><br><span class="line"><span class="regexp">//</span> total:<span class="number">10</span>,cur:<span class="number">1</span>,index:<span class="number">0</span></span><br><span class="line"><span class="regexp">//</span> total:<span class="number">11</span>,cur:<span class="number">2</span>,index:<span class="number">1</span></span><br><span class="line"><span class="regexp">//</span> total:<span class="number">13</span>,cur:<span class="number">3</span>,index:<span class="number">2</span></span><br><span class="line"><span class="regexp">//</span> total:<span class="number">16</span>,cur:<span class="number">4</span>,index:<span class="number">3</span></span><br><span class="line"><span class="regexp">//</span> total:<span class="number">20</span>,cur:<span class="number">5</span>,index:<span class="number">4</span></span><br><span class="line"><span class="regexp">//</span> 结果：<span class="number">25</span></span><br></pre></td></tr></table></figure><p>从上面代码我们可以看出，当我们不给函数传递迭代初始值时初始值 total 为数组第一项，函数从数组第二项开始迭代；若我们给函数传递迭代初始值，则函数从数组第一项开始迭代。</p><h3 id="我的个人总结注意点"><a href="#我的个人总结注意点" class="headerlink" title="我的个人总结注意点:"></a>我的个人总结注意点:</h3><ol><li>reduce方法使用技巧很多,能实现很多想不到的事,具体可以参照lucas小册学习笔记的”实现API”章节</li><li>不会就去查MDN</li></ol>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组方法总结(基础)</title>
      <link href="2020/04/18/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93(%E5%9F%BA%E7%A1%80)/"/>
      <url>2020/04/18/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93(%E5%9F%BA%E7%A1%80)/</url>
      
        <content type="html"><![CDATA[<h3 id="join-（数组转字符串）"><a href="#join-（数组转字符串）" class="headerlink" title="join() （数组转字符串）"></a>join() （数组转字符串）</h3><p>数组转字符串，方法只接收一个参数：即默认为逗号分隔符（）。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="attribute">console</span>.log(arr.join()); //<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line"><span class="attribute">console</span>.log(arr.join(<span class="string">&quot;:&quot;</span>)); //<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span></span><br><span class="line"><span class="attribute">console</span>.log(arr); //[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],原数组不变</span><br></pre></td></tr></table></figure><p>join()实现重复字符串</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> repeat<span class="constructor">Str(<span class="params">str</span>, <span class="params">n</span>)</span> &#123;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">Array(<span class="params">n</span> + 1)</span>.join(str);</span><br><span class="line">&#125;</span><br><span class="line">console.log(repeat<span class="constructor">Str(<span class="string">&quot;嗨&quot;</span>,3)</span>); <span class="comment">//嗨嗨嗨</span></span><br><span class="line">console.log(repeat<span class="constructor">Str(<span class="string">&quot;Hi&quot;</span>,3)</span>); <span class="comment">//HiHiHi</span></span><br><span class="line">console.log(repeat<span class="constructor">Str(1,3)</span>);    <span class="comment">//111</span></span><br></pre></td></tr></table></figure><h3 id="push-和pop-（数组尾操作）"><a href="#push-和pop-（数组尾操作）" class="headerlink" title="push()和pop()（数组尾操作）"></a>push()和pop()（数组尾操作）</h3><p>push()：方法可向数组的末尾添加一个或多个元素，并返回新的长度。<br>pop()：方法用于删除并返回数组的最后一个元素。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="regexp">//</span>push</span><br><span class="line">var push_arr=arr.push(<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Sun&quot;</span>);</span><br><span class="line">console.log(arr); <span class="regexp">//</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;Sun&quot;</span>];</span><br><span class="line">console.log(push_arr); <span class="regexp">//</span> <span class="number">6</span></span><br><span class="line"><span class="regexp">//</span>pop</span><br><span class="line">var pop_arr=arr.pop();</span><br><span class="line">console.log(arr); <span class="regexp">//</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;Tom&quot;</span>];</span><br><span class="line">console.log(pop_arr); <span class="regexp">//</span> Sun</span><br></pre></td></tr></table></figure><h3 id="shift-和-unshift-（数组首操作）"><a href="#shift-和-unshift-（数组首操作）" class="headerlink" title="shift() 和 unshift()（数组首操作）"></a>shift() 和 unshift()（数组首操作）</h3><p>shift()：方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。<br>unshift()：方法可向数组的开头添加一个或更多元素，并返回新的长度。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="regexp">//</span>shift</span><br><span class="line">var shift_arr=arr.shift();</span><br><span class="line">console.log(arr); <span class="regexp">//</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">console.log(shift_arr); <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line"><span class="regexp">//u</span>nshift</span><br><span class="line">var unshift_arr=arr.unshift(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">console.log(arr); <span class="regexp">//</span> [<span class="string">&quot;Tom&quot;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">console.log(unshift_arr); <span class="regexp">//</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="sort-（排序）"><a href="#sort-（排序）" class="headerlink" title="sort()（排序）"></a>sort()（排序）</h3><p>方法用于对数组的元素进行排序。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">arr=[1,100,5,20];</span></span><br><span class="line"><span class="string">console.log(arr.sort());</span> <span class="string">//</span> [<span class="number">1</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">5</span>]</span><br><span class="line"><span class="string">console.log(arr);</span> <span class="string">//</span> [<span class="number">1</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">5</span>] <span class="string">(原数组改变)</span></span><br></pre></td></tr></table></figure><p>请注意，上面的代码没有按照数值的大小对数字进行排序，是按照字符编码的顺序进行排序，要实现这一点，就必须使用一个排序函数：<br>升序：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var</span> arr=[<span class="number">1</span>,<span class="number">100</span>,<span class="number">5</span>,<span class="number">20</span>];</span><br><span class="line"><span class="attribute">function</span> sortNumber(a,b)&#123;return a - b&#125;;</span><br><span class="line"><span class="attribute">console</span>.log(arr.sort(sortNumber)); //[<span class="number">1</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">100</span>]</span><br><span class="line"><span class="attribute">console</span>.log(arr); //[<span class="number">1</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">100</span>] (原数组改变)</span><br></pre></td></tr></table></figure><p>降序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">100</span>,<span class="number">5</span>,<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumber</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> b - a&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(sortNumber)); <span class="comment">// [100, 20, 5, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [100, 20, 5, 1] (原数组改变)</span></span><br></pre></td></tr></table></figure><h3 id="reverse-（反转数组）"><a href="#reverse-（反转数组）" class="headerlink" title="reverse() （反转数组）"></a>reverse() （反转数组）</h3><p>方法用于颠倒数组中元素的顺序。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">arr=[12,25,5,20];</span></span><br><span class="line"><span class="string">console.log(arr.reverse());</span> <span class="string">//</span> [<span class="number">20</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">12</span>]</span><br><span class="line"><span class="string">console.log(arr);</span> <span class="string">//</span> [<span class="number">20</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">12</span>] <span class="string">(原数组改变)</span></span><br></pre></td></tr></table></figure><h3 id="concat-（连接两个或多个数组）"><a href="#concat-（连接两个或多个数组）" class="headerlink" title="concat() （连接两个或多个数组）"></a>concat() （连接两个或多个数组）</h3><p>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">arr=[1,2,3,4];</span></span><br><span class="line"><span class="string">var</span> <span class="string">arr2=[11,12,13]</span> </span><br><span class="line"><span class="string">var</span> <span class="string">arrCopy</span> <span class="string">=</span> <span class="string">arr.concat(arr2);</span></span><br><span class="line"><span class="string">console.log(arr.concat());</span> <span class="string">//</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="string">(复制数组)</span></span><br><span class="line"><span class="string">console.log(arrCopy);</span> <span class="string">//</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line"><span class="string">console.log(arr);</span> <span class="string">//</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="string">(原数组未改变)</span></span><br></pre></td></tr></table></figure><p>如果传入的参数是一个二维数组呢？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="attribute">var</span> arr<span class="number">2</span>=[<span class="number">11</span>,[<span class="number">12</span>,<span class="number">13</span>]] </span><br><span class="line"><span class="attribute">var</span> arrCopy = arr.concat(arr<span class="number">2</span>);</span><br><span class="line"><span class="attribute">console</span>.log(arrCopy); //<span class="meta"> [1, 2, 3, 4, 11, Array(2)]</span></span><br><span class="line"><span class="attribute">console</span>.log(arr); //<span class="meta"> [1, 2, 3, 4] (原数组未改变)</span></span><br></pre></td></tr></table></figure><p>从上面代码中可以看出concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy中。</p><h3 id="slice-（数组截取）"><a href="#slice-（数组截取）" class="headerlink" title="slice()（数组截取）"></a>slice()（数组截取）</h3><p>arr.slice(start , end);</p><p>start：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</p><p>end：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p><p>返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arr 中的元素。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">arr</span> <span class="string">=</span> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">12</span>]<span class="string">;</span></span><br><span class="line"><span class="string">var</span> <span class="string">arrCopy1</span> <span class="string">=</span> <span class="string">arr.slice(1);</span></span><br><span class="line"><span class="string">var</span> <span class="string">arrCopy2</span> <span class="string">=</span> <span class="string">arr.slice(0,4);</span></span><br><span class="line"><span class="string">var</span> <span class="string">arrCopy3</span> <span class="string">=</span> <span class="string">arr.slice(1,-2);</span></span><br><span class="line"><span class="string">var</span> <span class="string">arrCopy4</span> <span class="string">=</span> <span class="string">arr.slice(-5,4);</span></span><br><span class="line"><span class="string">var</span> <span class="string">arrCopy5</span> <span class="string">=</span> <span class="string">arr.slice(-4,-1)</span></span><br><span class="line"><span class="string">console.log(arrCopy1);</span>  <span class="string">//</span> [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>]</span><br><span class="line"><span class="string">console.log(arrCopy2);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>] </span><br><span class="line"><span class="string">console.log(arrCopy3);</span>  <span class="string">//</span> [<span class="number">4</span>, <span class="number">6</span>] </span><br><span class="line"><span class="string">console.log(arrCopy4);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="string">console.log(arrCopy5);</span>  <span class="string">//</span> [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="string">console.log(arr);</span>  <span class="string">//</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>] <span class="string">(原数组未改变)</span> </span><br></pre></td></tr></table></figure><h3 id="splice-（数组更新）"><a href="#splice-（数组更新）" class="headerlink" title="splice() （数组更新）"></a>splice() （数组更新）</h3><p>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。（该方法会改变原始数组）</p><p>arr.splice(index , howmany , item1,…..,itemX)</p><p>index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</p><p>howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。</p><p>item1, …, itemX：可选。向数组添加的新项目。</p><p>返回值：含有被删除的元素的数组，若没有删除元素则返回一个空数组。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;小红&quot;</span>];</span><br><span class="line"><span class="regexp">/**************删除&quot;王五&quot;****************/</span></span><br><span class="line">var arrReplace1 = arr.splice(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">console.log(arrReplace1);  <span class="regexp">//</span> [<span class="string">&quot;王五&quot;</span>] </span><br><span class="line">console.log(arr);  <span class="regexp">//</span> [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;小红&quot;</span>] (原数组改变)</span><br><span class="line"><span class="regexp">//</span>删除多个</span><br><span class="line">var arrReplace2 = arr.splice(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">console.log(arrReplace2);  <span class="regexp">//</span>  [<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;小明&quot;</span>] </span><br><span class="line">console.log(arr);  <span class="regexp">//</span> [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;小红&quot;</span>]</span><br><span class="line"><span class="regexp">/**************添加&quot;小刚&quot;****************/</span></span><br><span class="line">var arrReplace3 = arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line">console.log(arrReplace3);  <span class="regexp">//</span> [] (没有删除元素，所以返回的是空数组)</span><br><span class="line">console.log(arr);  <span class="regexp">//</span> [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;小刚&quot;</span>, <span class="string">&quot;小红&quot;</span>]</span><br><span class="line"><span class="regexp">//</span>添加多个</span><br><span class="line">var arrReplace4 = arr.splice(<span class="number">3</span>,<span class="number">0</span>,<span class="string">&quot;刘一&quot;</span>,<span class="string">&quot;陈二&quot;</span>,<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">console.log(arrReplace4);  <span class="regexp">//</span> []</span><br><span class="line">console.log(arr);  <span class="regexp">//</span> [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;小刚&quot;</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;刘一&quot;</span>, <span class="string">&quot;陈二&quot;</span>, <span class="string">&quot;赵六&quot;</span>]</span><br><span class="line"><span class="regexp">/**************&quot;王五&quot;替换&quot;小刚&quot;****************/</span></span><br><span class="line">var arrReplace5 = arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">console.log(arrReplace5);  <span class="regexp">//</span> [<span class="string">&quot;小刚&quot;</span>]</span><br><span class="line">console.log(arr);  <span class="regexp">//</span> [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;刘一&quot;</span>, <span class="string">&quot;陈二&quot;</span>, <span class="string">&quot;赵六&quot;</span>]</span><br><span class="line"><span class="regexp">//</span>替换多个</span><br><span class="line">var arrReplace6 = arr.splice(<span class="number">1</span>,<span class="number">4</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">console.log(arrReplace6);  <span class="regexp">//</span> [<span class="string">&quot;王五&quot;</span>, <span class="string">&quot;小红&quot;</span>, <span class="string">&quot;刘一&quot;</span>, <span class="string">&quot;陈二&quot;</span>]</span><br><span class="line">console.log(arr);  <span class="regexp">//</span> [<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;赵六&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="我的个人总结注意点"><a href="#我的个人总结注意点" class="headerlink" title="我的个人总结注意点:"></a>我的个人总结注意点:</h3><ol><li>新建固定长度数组,只能用new Array()</li><li>Array.prototype.join()与Array.prototype.toString()方法很相似</li><li>push()和pop(),shift() 和 unshift()增加的返回数组长度,减少的返回减少项</li><li>slice不会改变原数组,可以用于浅拷贝;splice会改变原数组</li><li>不会就去查MDN</li></ol>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021金三银四练习</title>
      <link href="2020/03/31/2021%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9B%E7%BB%83%E4%B9%A0/"/>
      <url>2020/03/31/2021%E9%87%91%E4%B8%89%E9%93%B6%E5%9B%9B%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="编写一个方法，该方法接收两个参数，分别为-k-和-一个无序的纯数字数组。该方法在执行后，会返回数组中第-k-大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如-3-1-3-2-5-4-5-中，第-1-大的数字为-5，第2大的数字为-4，第5大的数字为-1？"><a href="#编写一个方法，该方法接收两个参数，分别为-k-和-一个无序的纯数字数组。该方法在执行后，会返回数组中第-k-大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如-3-1-3-2-5-4-5-中，第-1-大的数字为-5，第2大的数字为-4，第5大的数字为-1？" class="headerlink" title="编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1？"></a>编写一个方法，该方法接收两个参数，分别为 k 和 一个无序的纯数字数组。该方法在执行后，会返回数组中第 k 大的数字。特别注意，如果数组中，有两位数值一样的数字，同数值数字排名并列。如 [3,1,3,2,5,4,5] 中，第 1 大的数字为 5，第2大的数字为 4，第5大的数字为 1？</h3><ul><li>思路就是先去重，再排序<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span></span>(k,arr)&#123;</span><br><span class="line">    <span class="comment">//先去重</span></span><br><span class="line">    let <span class="keyword">new</span><span class="type">Arr</span> = [...<span class="keyword">new</span> <span class="type">Set</span>(arr)]</span><br><span class="line">    <span class="comment">//参数验证</span></span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">1</span>||k&gt;<span class="keyword">new</span><span class="type">Arr</span>.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">new</span><span class="type">Arr</span>.sort((a,b)=&gt;b-a)</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Arr</span>[k<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">console.log(fn(<span class="number">1</span>,[<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure></li></ul><h3 id="proto-和-prototype-之前有什么关系？"><a href="#proto-和-prototype-之前有什么关系？" class="headerlink" title="proto 和 prototype 之前有什么关系？"></a><strong>proto</strong> 和 prototype 之前有什么关系？</h3><p>首先，所有对象都有__proto__属性，函数这个特殊对象除了有__proto__属性，还有特有的原型属性prototype。<br>然后，prototype对象默认有两个属性，constructor属性和__proto__属性，prototype属性可以给函数和对象添加可共享（继承）的方法、属性；而__proto__是查找某函数或对象的原型链方式。<br>constructor这个属性包含了一个指针指回原构造函数。</p><h3 id="call-apply-，bind-的区别和作用？bind-方法如何来实现？"><a href="#call-apply-，bind-的区别和作用？bind-方法如何来实现？" class="headerlink" title="call(), apply()，bind() 的区别和作用？bind 方法如何来实现？"></a>call(), apply()，bind() 的区别和作用？bind 方法如何来实现？</h3><ul><li>call，apply，bind都是函数原型上的方法</li><li>call是执行函数，并且函数第一个参数为函数的this指向</li><li>apply是执行函数，函数第一个参数为函数的this指向，第二个参数是剩余形参的一个数组</li><li>bind第一个参数为函数的this指向，并且返回一个函数</li></ul><p>bind手写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">var</span> me = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">        <span class="keyword">return</span> me.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> F ? <span class="built_in">this</span> : context || <span class="built_in">this</span>, finalArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    bound.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js中基础数据类型有哪几种-了解包装对象么？"><a href="#js中基础数据类型有哪几种-了解包装对象么？" class="headerlink" title="js中基础数据类型有哪几种?了解包装对象么？"></a>js中基础数据类型有哪几种?了解包装对象么？</h3><ul><li>5种基本类型，Number，String，Boolean，undefined，null</li><li>对象包装：new Number(),new String(),new Boolean()，返回的都是object类型<br>Number()，String()，Boolean()，返回的是对应的基础类型</li></ul><h3 id="如何判断this？箭头函数的this是什么？"><a href="#如何判断this？箭头函数的this是什么？" class="headerlink" title="如何判断this？箭头函数的this是什么？"></a>如何判断this？箭头函数的this是什么？</h3><ol><li>在函数体中，简单调用该函数时（非显式/隐式绑定下），严格模式下 this 绑定到 undefined，否则绑定到全局对象 window／global；</li><li>一般构造函数 new 调用，绑定到新创建的对象上；</li><li>一般由 call/apply/bind 方法显式调用，绑定到指定参数的对象上；</li><li>一般由上下文对象调用，绑定在该对象上；</li><li>箭头函数中，根据外层上下文绑定的 this 决定 this 指向。</li><li>如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例。</li></ol><h3 id="什么是同步？什么是异步？"><a href="#什么是同步？什么是异步？" class="headerlink" title="什么是同步？什么是异步？"></a>什么是同步？什么是异步？</h3><p>同步和异步是一种消息通知机制</p><ul><li>同步阻塞: A调用B，B处理获得结果，才返回给A。A在这个过程中，一直等待B的处理结果，没有拿到结果之前，需要A（调用者）一直等待和确认调用结果是否返回，拿到结果,然后继续往下执行。   做一件事，没有拿到结果之前，就一直在这等着，一直等到有结果了,再去做下边的事</li><li>异步非阻塞: A调用B，无需等待B的结果，B通过状态，通知等来通知A或回调函数来处理。</li></ul><h3 id="什么是宏任务？什么是微任务？"><a href="#什么是宏任务？什么是微任务？" class="headerlink" title="什么是宏任务？什么是微任务？"></a>什么是宏任务？什么是微任务？</h3><ul><li>微任务：一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。  </li><li>宏任务：宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。  </li><li>常见微任务：1. Promise.thenMutaionObserverObject.observe（已废弃；Proxy 对象替代）process.nextTick（Node.js） </li><li>常见宏任务：1. script (可以理解为外层同步代码)  2. setTimeout/setInterval  3. UI rendering/UI事件  4.postMessage，MessageChannel  5. setImmediate，I/O（Node.js）</li></ul><h3 id="什么是回调-回调使用中存在什么问题"><a href="#什么是回调-回调使用中存在什么问题" class="headerlink" title="什么是回调?回调使用中存在什么问题?"></a>什么是回调?回调使用中存在什么问题?</h3><p>回调即是函数指针的调用，即是一个通过函数指针调用的函数。使用回调函数有一个很大缺点 就是造成回调地狱，回到地狱是 为了实现某些逻辑出现函数的层层嵌套。回调地狱会造成可读性及可维护性变差。同样每个嵌套函数耦合性强，一层变动会引起其他的结果变动。同样回调地狱如果出现错误不好处理错误。解决回调地狱问题可以通过观察者模式、promise、async /await来处理。</p><h3 id="Promise-allSettled-了解吗？动手实现一下-Promise-allSettled"><a href="#Promise-allSettled-了解吗？动手实现一下-Promise-allSettled" class="headerlink" title="Promise.allSettled 了解吗？动手实现一下 Promise.allSettled?"></a>Promise.allSettled 了解吗？动手实现一下 Promise.allSettled?</h3><p>Promise.allSettled是ES2020新特性，可以执行多个promise对象，获取多个promise对象状态，无论成功或者失败的状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">MyallSettled</span>(<span class="params">list</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> resArr = <span class="keyword">new</span> <span class="built_in">Array</span>(list.length);</span><br><span class="line">       <span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;    </span><br><span class="line">            list.forEach(<span class="function">(<span class="params">item,key</span>)=&gt;</span>&#123;</span><br><span class="line">               <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">               obj[<span class="string">&#x27;status&#x27;</span>] = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">               obj.value = res;</span><br><span class="line">               resArr[key] = obj;</span><br><span class="line">               num++</span><br><span class="line">               <span class="keyword">if</span>(num===list.length)&#123;</span><br><span class="line">                   resolve(resArr); </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">               obj[<span class="string">&#x27;status&#x27;</span>] = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">               obj.reson = err;</span><br><span class="line">               resArr[key] = obj;</span><br><span class="line">               num++</span><br><span class="line">               <span class="keyword">if</span>(num===list.length)&#123;</span><br><span class="line">                   resolve(resArr); </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vue-中组件间有哪些通信方式"><a href="#vue-中组件间有哪些通信方式" class="headerlink" title="vue 中组件间有哪些通信方式?"></a>vue 中组件间有哪些通信方式?</h3><ol><li>props / $emit适用于父子组件通信这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</li><li>ref 与 $parent / $children适用于父子组件通信ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例$parent / $children：访问父 / 子实例</li><li>EventBus （$emit / $on）适用于父子、隔代、兄弟组件通信这种方法通过一个空的 Vue 实例/作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</li><li>$attrs/$listeners适用于隔代组件通信$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=“$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。<code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=“$listeners” 传入内部组件</li><li>provide / inject适用于隔代组件通信祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系</li><li>Vuex适用于父子、隔代、兄弟组件通信Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ol><h3 id="vue-中-v-show-和-v-if-的区别是什么？"><a href="#vue-中-v-show-和-v-if-的区别是什么？" class="headerlink" title="vue 中 v-show 和 v-if 的区别是什么？"></a>vue 中 v-show 和 v-if 的区别是什么？</h3><ul><li>v-show 只是在 display: none 和 display: block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。</li><li>v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</li></ul><h3 id="keep-alive-组件有什么作用？"><a href="#keep-alive-组件有什么作用？" class="headerlink" title="keep-alive 组件有什么作用？"></a>keep-alive 组件有什么作用？</h3><ul><li> 如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。  </li><li>对于 keep-alive 组件来说，它拥有两个独有的生命周期钩子函数，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</li></ul><h3 id="说下vue生命周期钩子函数"><a href="#说下vue生命周期钩子函数" class="headerlink" title="说下vue生命周期钩子函数?"></a>说下vue生命周期钩子函数?</h3><ul><li>beforeCreate :这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到。</li><li>created这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作。</li><li>beforeMounte：在挂载开始之前被调用：相关的 render 函数首次被调用</li><li>mounted：挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行</li><li>beforeUpdate：data中数据已经更新完毕，页面视图还未响应更改</li><li>updated：数据和视图都更新完毕</li><li>beforeDestroy：销毁之前，实例上事件、指令等都可以使用，这里组件没有真正的销毁。</li><li>destroyed：数据、指令、等完全销毁</li></ul><h3 id="Vue中computed和watch区别"><a href="#Vue中computed和watch区别" class="headerlink" title="Vue中computed和watch区别?"></a>Vue中computed和watch区别?</h3><ul><li>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。 </li><li>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</li></ul><h3 id="React-的组件间通信都有哪些形式？"><a href="#React-的组件间通信都有哪些形式？" class="headerlink" title="React 的组件间通信都有哪些形式？"></a>React 的组件间通信都有哪些形式？</h3><ol><li>父传子：在 React 中，父组件调用子组件时可以将要传递给子组件的数据添加在子组件的属性中，在子组件中通过 props 属性进行接收。这个就是父组件向子组件通信。</li><li>子传父：React 是单向数据流，数据永远只能自上向下进行传递。当子组件中有些数据需要向父级进行通信时，需要在父级中定义好回调，将回调传递给子组件，子组件调用父级传递过来的回调方法进行通信。</li><li>跨组件通信 - context。使用 context API，可以在组件中向其子孙级组件进行信息传递。</li></ol><h3 id="React中如何实现路由懒加载？"><a href="#React中如何实现路由懒加载？" class="headerlink" title="React中如何实现路由懒加载？"></a>React中如何实现路由懒加载？</h3><p>在 React 16 中，新增了 lazy 方法，通过 lazy 方法可以轻松实现组件懒加载，当然要实现路由懒加载的话，其实也只需要把路由组件结合 lazy 使用即可。  参考代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Route&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line">        <span class="keyword">import</span> React,&#123;Suspense&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">        <span class="keyword">const</span> HomeView = React.lazy(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;./home&quot;</span>));</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>路由懒加载<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">                  &lt;Route path=&quot;/&quot; exact render=&#123;()=&gt;&#123;</span><br><span class="line">                            return &lt;Suspense fallback=&#123;&lt;div&gt;组件Loading进来之前的占位内容&lt;/div&gt;&#125;&gt;                    </span><br><span class="line">                    &lt;HomeView /&gt;              </span><br><span class="line">                    &lt;/Suspense&gt;              </span><br><span class="line"><span class="xml">                    &#125;&#125; /&gt;           </span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>        </span><br><span class="line">                    &#125;        </span><br><span class="line">                    <span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用 lazy 引入了一个动态组件，然后将该组件放入了根路由中。这样的话只有用户访问网站首页时，才会动态加载这个组件。  这里要注意，在 React 规范中，lazy 和 Suspense 必须配合使用，lazy 引入的动态组件必须要放入 Suspense 中，Suspense 的 fallback 属性是 lazy 的组件没有加载进来之前的占位内容。</p><h3 id="React-的生命周期函数都有哪些，分别有什么作用？"><a href="#React-的生命周期函数都有哪些，分别有什么作用？" class="headerlink" title="React 的生命周期函数都有哪些，分别有什么作用？"></a>React 的生命周期函数都有哪些，分别有什么作用？</h3><ul><li>挂载阶段：</li></ul><ol><li>constructor: 初始化组件，初始化组件的 state 等。</li><li>static getDerivedStateFromProps()：该函数用于将 props 中的信息映射到 state 中。</li><li>render: 生成虚拟DOM</li><li>componentDidMount：组件挂载完成，通过在该函数中去处理副作用 </li></ol><ul><li>更新阶段：</li></ul><ol><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate()：该生命周期函数用于判断是否要进行组件更新。</li><li>render()：生成虚拟DOM</li><li>getSnapshotBeforeUpdate()：组件已经完成 diff，即将更新真实 DOM，用户获取上一次的DOM快照。该函数必须搭配componentDidUpdate 一块使用，返回值会变成 componentDidUpdate 第三个参数。</li><li>componentDidUpdate()： 组件更新完成，通常在该函数中进行副作用处理。 即将卸载： componentWillUnmount：组件即将卸载，用于删除组件添加到全局的数据或事件。</li></ol><h3 id="请描述一下-cookies-sessionStorage和localstorage区别？"><a href="#请描述一下-cookies-sessionStorage和localstorage区别？" class="headerlink" title="请描述一下 cookies sessionStorage和localstorage区别？"></a>请描述一下 cookies sessionStorage和localstorage区别？</h3><ol><li>cookie在浏览器与服务器之间来回传递；sessionStorage和localStorage不会把数据发给服务器，仅在本地保存</li><li>数据有效期不同，cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭；sessionStorage：仅在当前浏览器窗口关闭前有效；localStorage 始终有效，长期保存</li><li>作用域不用，sessionStorage不在不同的浏览器窗口中共享；sessionStorage不在不同的浏览器窗口中共享；cookie也是在所有同源窗口中都是共享的</li><li>存储大小不同，cookie数据不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li></ol><h3 id="浏览器为什么要阻止跨域请求-如何解决跨域-每次跨域请求都需要-到达服务端吗-快手"><a href="#浏览器为什么要阻止跨域请求-如何解决跨域-每次跨域请求都需要-到达服务端吗-快手" class="headerlink" title="浏览器为什么要阻止跨域请求? 如何解决跨域?每次跨域请求都需要 到达服务端吗?(快手)"></a>浏览器为什么要阻止跨域请求? 如何解决跨域?每次跨域请求都需要 到达服务端吗?(快手)</h3><p>因为会有XSS攻击，所以浏览器要阻止跨域。JSONP，CORS资源共享，nginx代理，nodejs中间件代理，WebSocket协议跨域。跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。<br>每次需求都会发出，服务器端也会做出响应，只是浏览器端在接受响应的时候会基于同源策略进行拦截。有些浏览器不允许从 HTTPS 的跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。</p><h3 id="Token-一般是存放在哪里-Token-放在-cookie-和放在localStorage、sessionStorage-中有什么不同"><a href="#Token-一般是存放在哪里-Token-放在-cookie-和放在localStorage、sessionStorage-中有什么不同" class="headerlink" title="Token 一般是存放在哪里? Token 放在 cookie 和放在localStorage、sessionStorage 中有什么不同?"></a>Token 一般是存放在哪里? Token 放在 cookie 和放在localStorage、sessionStorage 中有什么不同?</h3><p>一般放在localStorage中，虽然容易容易受到XSS攻击。放在cookie中则容易受到CSRF攻击，且不符合Restful 最佳实践。</p><h3 id="WebSocket-是怎么实现点对点通信和广播通信的？"><a href="#WebSocket-是怎么实现点对点通信和广播通信的？" class="headerlink" title="WebSocket 是怎么实现点对点通信和广播通信的？"></a>WebSocket 是怎么实现点对点通信和广播通信的？</h3><p>广播式即服务端有消息时，会将所有消息发送给连接了当前endpoint的浏览器。</p>]]></content>
      
      
      <categories>
          
          <category> 面试练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小工具插件网址推荐</title>
      <link href="2020/02/04/%E5%B0%8F%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6%E7%BD%91%E5%9D%80%E6%8E%A8%E8%8D%90/"/>
      <url>2020/02/04/%E5%B0%8F%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6%E7%BD%91%E5%9D%80%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<ol><li>jsrun,codesandbox(科学上网),可以进行在线编辑</li></ol>]]></content>
      
      
      <categories>
          
          <category> 摸鱼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bind手写(Lucas小册1-1番外篇)</title>
      <link href="2019/11/16/%E6%89%8B%E5%86%99bind/"/>
      <url>2019/11/16/%E6%89%8B%E5%86%99bind/</url>
      
        <content type="html"><![CDATA[<h4 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> me = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">//伪数组转换成数组,并且预存初始参数</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(me)</span><br><span class="line">        <span class="built_in">console</span>.log(args)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bound</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//获取二次传入的参数</span></span><br><span class="line">            <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">            <span class="comment">//拼为最终参数</span></span><br><span class="line">            <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">            <span class="built_in">console</span>.log(innerArgs)</span><br><span class="line">            <span class="built_in">console</span>.log(finalArgs)</span><br><span class="line">            <span class="keyword">return</span> me.apply(context, finalArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="能在构造函数场景下兼容"><a href="#能在构造函数场景下兼容" class="headerlink" title="能在构造函数场景下兼容"></a>能在构造函数场景下兼容</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">var</span> me = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">        <span class="keyword">return</span> me.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> F ? <span class="built_in">this</span> : context || <span class="built_in">this</span>, finalArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    bound.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bind的偏函数用法-可以用于预设参数"><a href="#bind的偏函数用法-可以用于预设参数" class="headerlink" title="bind的偏函数用法,可以用于预设参数"></a>bind的偏函数用法,可以用于预设参数</h4><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAuguments</span>(<span class="params">arg1,arg2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1+arg2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> listRe = <span class="built_in">list</span>.bind(<span class="literal">null</span>,<span class="number">37</span>)</span><br><span class="line"><span class="keyword">let</span> addRe = addAuguments.bind(<span class="literal">null</span>,<span class="number">37</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(listRe(<span class="number">12</span>,<span class="number">54</span>))<span class="comment">//[ 37, 12, 54 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(addRe(<span class="number">12</span>,<span class="number">54</span>))<span class="comment">//49</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lucas小册学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS小技巧</title>
      <link href="2019/10/25/JS%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>2019/10/25/JS%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="在内层循环终结外层循环"><a href="#在内层循环终结外层循环" class="headerlink" title="在内层循环终结外层循环"></a>在内层循环终结外层循环</h3><p>最捉鸡的方法，引入一个控制变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var func = <span class="function"><span class="keyword">function</span> <span class="params">()</span>&#123;</span></span><br><span class="line">    var flag = <span class="built_in">false</span>;</span><br><span class="line">    <span class="keyword">for</span>( var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span>&lt; <span class="number">10</span>; <span class="built_in">i</span>++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (var <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span>&lt;<span class="number">10</span>; <span class="built_in">j</span>++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">i</span>*<span class="built_in">j</span>&gt;<span class="number">30</span>)&#123;</span><br><span class="line">               flag =<span class="built_in">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的方式是直接用return，但这样会导致循环外的逻辑无法执行，所以需要把循环后的代码，通过函数返回</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var print = <span class="function"><span class="keyword">function</span> <span class="params">(i)</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">i</span>)</span><br><span class="line">&#125;;</span><br><span class="line">var func = <span class="function"><span class="keyword">function</span> <span class="params">()</span>&#123;</span></span><br><span class="line">    <span class="keyword">for</span>( var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span>&lt; <span class="number">10</span>; <span class="built_in">i</span>++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (var <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span>&lt;<span class="number">10</span>; <span class="built_in">j</span>++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">i</span>*<span class="built_in">j</span>&gt;<span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> print (<span class="built_in">i</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期详细描述</title>
      <link href="2019/10/25/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/"/>
      <url>2019/10/25/vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1、响应式处理</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$options = options;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$data = options.data()</span></span><br><span class="line"><span class="javascript">        observer(<span class="built_in">this</span>.$data)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    Vue.prototype.$mount = <span class="function"><span class="keyword">function</span>(<span class="params">sel</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//获得渲染之后的dom结构，追加到宿主元素</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//创建更新函数，$mount就是初始化</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.updata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;undata&#x27;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="comment">//首次执行，执行挂载</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> vnode = <span class="built_in">this</span>.$options.render.call(<span class="built_in">this</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(!<span class="built_in">this</span>.isMounted)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> parent = <span class="built_in">document</span>.querySelector(sel)</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.patch(parent,vnode)</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.isMounted = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 如果有生命周期函数</span></span></span><br><span class="line">                parent.appendChild(child)</span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(<span class="built_in">this</span>.$options.mounted)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">//指定下上下文</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.$options.mounted.call(<span class="built_in">this</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                 <span class="comment">// 以后执行更新</span></span></span><br><span class="line"><span class="javascript">                 <span class="comment">//_vnode就是上一次虚拟dom</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.patch(<span class="built_in">this</span>._vnode,vnode)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>._vnode = vnode</span></span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.updata()</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    Vue.prototype.createElement = <span class="function"><span class="keyword">function</span>(<span class="params">tag,props,children</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;tag,props,children&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">//n1是宿主元素或旧的vnode，n2是新vnode</span></span></span><br><span class="line"><span class="javascript">    Vue.prototype.patch= <span class="function"><span class="keyword">function</span>(<span class="params">n1,n2</span>)</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">//拦截对象属性方法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">obj</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;defineReactive(obj,key,obj[key])&#125;)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//遍历obj每一个key，</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//定义一个响应式</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,val</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span></span><br><span class="line">            get()&#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>,key)</span></span><br><span class="line"><span class="javascript">                <span class="comment">//典型的闭包应用，每执行一次defineReactive，就保存一次变量</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> val</span></span><br><span class="line">            &#125;,</span><br><span class="line">            set(newVal)&#123;</span><br><span class="line">                if(newVal !== val)&#123;</span><br><span class="line">                    val = newVal</span><br><span class="line">                    kvue.updata()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> kvue = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line">        data()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                title:<span class="string">&#x27;标题&#x27;</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$data.title = <span class="string">&#x27;标题变了&#x27;</span></span></span><br><span class="line">            &#125;,1000)</span><br><span class="line">        &#125;,</span><br><span class="line">        render()&#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>  h(<span class="string">&#x27;h3&#x27;</span>,<span class="literal">null</span>,<span class="built_in">this</span>.$data.title)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    kvue.$mount(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期详细描述</title>
      <link href="2019/10/25/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0/"/>
      <url>2019/10/25/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>在此，我们详细描述一下vue的生命周期：</p><p>在谈到Vue的生命周期的时候，我们首先需要创建一个实例，也就是在 new Vue ( ) 的对象过程当中，首先执行了init（init是vue组件里面默认去执行的），在init的过程当中首先调用了beforeCreate，然后在injections（注射）和reactivity（反应性）的时候，它会再去调用created。</p><p>所以在init的时候，事件已经调用了，我们在beforeCreate的时候千万不要去修改data里面赋值的数据，最早也要放在created里面去做（添加一些行为）。</p><p>当created完成之后，它会去判断instance（实例）里面是否含有“el”option（选项），如果没有的话，它会调用vm.$mount(el)这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有“template”这个选项，如果有的话，它会把template解析成一个render function ，这是一个template编译的过程，结果是解析成了render函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render (h) &#123;  </span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="keyword">this</span>.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下，render函数里面的传参h就是Vue里面的createElement方法，return返回一个createElement方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数传了一个对象，对象里面可以是我们组件上面的props，或者是事件之类的东西；第三个参数就是div标签里面的内容，这里我们指向了data里面的text。</p><p>使用render函数的结果和我们之前使用template解析出来的结果是一样的。render函数是发生在beforeMount和mounted之间的，这也从侧面说明了，在beforeMount的时候，$el还只是我们在HTML里面写的节点，然后到mounted的时候，它就把渲染出来的内容挂载到了DOM节点上。这中间的过程其实是执行了render function的内容。</p><p>在使用.vue文件开发的过程当中，我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面。</p><p>这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。</p><p>beforeMount在有了render function的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕之后，这个实例就算是走完流程了。</p><p>后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用beforeUpdate，然后经过Virtual DOM，最后updated更新完毕。当组件被销毁的时候，它会调用beforeDestory，以及destoryed。</p><p>这就是vue实例从新建到销毁的一个完整流程，以及在这个过程中它会触发哪些生命周期的钩子函数。那说到这儿，可能很多童鞋会问，钩子函数是什么意思？</p><p>钩子函数，其实和回调是一个概念，当系统执行到某处时，检查是否有hook，有则回调。说的更直白一点，每个组件都有属性，方法和事件。所有的生命周期都归于事件，在某个时刻自动执行。</p><p>当然，如果你还想更进一步 ：</p><p>Vue为我们提供了renderError方法，这个方法只有在开发的时候它才会被调用，在正式打包上线的过程当中，它是不会被调用的。它主要是帮助我们调试render里面的一些错误。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renderError (<span class="keyword">h</span>, <span class="keyword">err</span>) &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">h</span>(&#x27;div&#x27;, &#123;&#125;, <span class="keyword">err</span>.<span class="keyword">stack</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有且只有当render方法里面报错了，才会执行renderError方法。<br>所以我们主动让render函数报个错：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render (h) &#123;  </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;render error&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this指向(Lucas小册1-1)</title>
      <link href="2019/06/14/this%E6%8C%87%E5%90%91/"/>
      <url>2019/06/14/this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ol><li>在函数体中，简单调用该函数时（非显式/隐式绑定下），严格模式下 this 绑定到 undefined，否则绑定到全局对象 window／global；</li><li>一般构造函数 new 调用，绑定到新创建的对象上；</li><li>一般由 call/apply/bind 方法显式调用，绑定到指定参数的对象上；</li><li>一般由上下文对象调用，绑定在该对象上；</li><li>箭头函数中，根据外层上下文绑定的 this 决定 this 指向。</li><li>如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；如果返回的不是一个对象，那么 this 仍然指向实例。</li></ol><p>伪数组:具有length属性,比如字符串</p><ol><li>arguments,</li><li>DOM对象列表,(document.getElemetsByTags)</li><li>Jqery对象,比如$(‘div’)</li><li>Set</li></ol>]]></content>
      
      
      <categories>
          
          <category> Lucas小册学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue优化九法</title>
      <link href="2019/05/22/vue%E4%BC%98%E5%8C%96%E4%B9%9D%E6%B3%95/"/>
      <url>2019/05/22/vue%E4%BC%98%E5%8C%96%E4%B9%9D%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="函数型组件"><a href="#函数型组件" class="headerlink" title="函数型组件"></a>函数型组件</h3><p>未优化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;value&quot;</span> <span class="attr">class</span>=<span class="string">&quot;on&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">&quot;off&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  props: [<span class="string">&#x27;value&#x27;</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优化后</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;props.value&quot;</span> <span class="attr">class</span>=<span class="string">&quot;on&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">&quot;off&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  props: [<span class="string">&#x27;value&#x27;</span>]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件拆分"><a href="#子组件拆分" class="headerlink" title="子组件拆分"></a>子组件拆分</h3><p>未优化:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; opacity: number / 300 &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">heavy</span>() &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml">  props: [&#x27;number&#x27;],</span></span><br><span class="line"><span class="xml">  methods: &#123;</span></span><br><span class="line"><span class="xml">    heavy () &#123; /* HEAVY TASK */ &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>已优化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; opacity: number / 300 &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChildComp</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  props: [<span class="string">&#x27;number&#x27;</span>],</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp: &#123;</span><br><span class="line">      methods: &#123;</span><br><span class="line"><span class="javascript">        heavy () &#123; <span class="comment">/* HEAVY TASK */</span> &#125;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      render (h) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.heavy())</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尽量将复杂逻辑拆分到子组件中</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>未优化</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; opacity: start / 300 &#125;&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">result</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">import &#123; heavy &#125; from &#x27;@/utils&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml">  props: [&#x27;start&#x27;],</span></span><br><span class="line"><span class="xml">  computed: &#123;</span></span><br><span class="line"><span class="xml">    base () &#123; return 42 &#125;,</span></span><br><span class="line"><span class="xml">    result () &#123;</span></span><br><span class="line"><span class="xml">      let result = this.start</span></span><br><span class="line"><span class="xml">      for (let i = 0; i <span class="tag">&lt; <span class="attr">1000</span>; <span class="attr">i</span>++) &#123;</span></span></span><br><span class="line"><span class="xml">        result += heavy(this.base)</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      return result</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>已优化</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; opacity: start / 300 &#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; <span class="name">result</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">import &#123; heavy &#125; from &#x27;@/utils&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml">  props: [&#x27;start&#x27;],</span></span><br><span class="line"><span class="xml">  computed: &#123;</span></span><br><span class="line"><span class="xml">    base () &#123; return 42 &#125;,</span></span><br><span class="line"><span class="xml">    result () &#123;</span></span><br><span class="line"><span class="xml">      const base = this.base</span></span><br><span class="line"><span class="xml">      let result = this.start</span></span><br><span class="line"><span class="xml">      for (let i = 0; i <span class="tag">&lt; <span class="attr">1000</span>; <span class="attr">i</span>++) &#123;</span></span></span><br><span class="line"><span class="xml">        result += heavy(base)</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      return result</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>使用局部变量缓存计算属性,不用每次去读取,提高性能</p><h3 id="活用v-show-少用v-if"><a href="#活用v-show-少用v-if" class="headerlink" title="活用v-show,少用v-if"></a>活用v-show,少用v-if</h3><p>未优化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;props.value&quot;</span> <span class="attr">class</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Heavy</span> <span class="attr">:n</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Heavy</span> <span class="attr">:n</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>已优化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;props.value&quot;</span> <span class="attr">class</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Heavy</span> <span class="attr">:n</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">v-show</span>=<span class="string">&quot;!props.value&quot;</span> <span class="attr">class</span>=<span class="string">&quot;off&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Heavy</span> <span class="attr">:n</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用keep-alive"><a href="#使用keep-alive" class="headerlink" title="使用keep-alive"></a>使用keep-alive</h3><p>未优化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>已优化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缓存组件</p><h3 id="活用延迟装载-defer"><a href="#活用延迟装载-defer" class="headerlink" title="活用延迟装载(defer)"></a>活用延迟装载(defer)</h3><p>未优化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>I&#x27;m an heavy page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Heavy</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;n&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Heavy</span> <span class="attr">class</span>=<span class="string">&quot;super-heavy&quot;</span> <span class="attr">:n</span>=<span class="string">&quot;9999999&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>已优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;I<span class="string">&#x27;m an heavy page&lt;/h2&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;template v-if=&quot;defer(2)&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;Heavy v-for=&quot;n in 10&quot; :key=&quot;n&quot;/&gt;</span></span><br><span class="line"><span class="string">    &lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;Heavy v-if=&quot;defer(3)&quot; class=&quot;super-heavy&quot; :n=&quot;9999999&quot;/&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">import Defer from &#x27;</span>@/mixins/Defer<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  mixins: [</span></span><br><span class="line"><span class="string">    Defer()</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Defer mixin</span></span><br><span class="line"><span class="string">export default function (count = 10) &#123;</span></span><br><span class="line"><span class="string">  return &#123;</span></span><br><span class="line"><span class="string">    data () &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        displayPriority: 0</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mounted () &#123;</span></span><br><span class="line"><span class="string">      this.runDisplayPriority()</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    methods: &#123;</span></span><br><span class="line"><span class="string">      runDisplayPriority () &#123;</span></span><br><span class="line"><span class="string">        const step = () =&gt; &#123;</span></span><br><span class="line"><span class="string">          requestAnimationFrame(() =&gt; &#123;</span></span><br><span class="line"><span class="string">            this.displayPriority++</span></span><br><span class="line"><span class="string">            if (this.displayPriority &lt; count) &#123;</span></span><br><span class="line"><span class="string">              step()</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">          &#125;)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        step()</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      defer (priority) &#123;</span></span><br><span class="line"><span class="string">        return this.displayPriority &gt;= priority</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>无法实际优化性能,只是改变装载顺序,让用户感觉流畅</p><h3 id="分批处理"><a href="#分批处理" class="headerlink" title="分批处理"></a>分批处理</h3><p>未优化</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetchItems (&#123; <span class="keyword">commit</span> &#125;, &#123; items &#125;) &#123;</span><br><span class="line">  <span class="keyword">commit</span>(<span class="string">&#x27;clearItems&#x27;</span>)</span><br><span class="line">  <span class="keyword">commit</span>(<span class="string">&#x27;addItems&#x27;</span>, items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fetchItems (&#123; commit &#125;, &#123; items, splitCount &#125;) &#123;</span><br><span class="line">  commit(<span class="string">&#x27;clearItems&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> JobQueue()</span><br><span class="line">  splitArray(items, splitCount).forEach(</span><br><span class="line">    chunk =&gt; queue.addJob(<span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Commit array chunks on several frames</span></span><br><span class="line">      requestAnimationFrame(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;addItems&#x27;</span>, chunk)</span><br><span class="line">        done()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// Start and wait for all the jobs</span></span><br><span class="line">  <span class="comment">// to finish</span></span><br><span class="line">  <span class="keyword">await</span> queue.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非响应模式"><a href="#非响应模式" class="headerlink" title="非响应模式"></a>非响应模式</h3><p>未优化</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">const</span> <span class="string">data = items.map(</span></span><br><span class="line">  <span class="attr">item</span> =<span class="string">&gt; (&#123;</span></span><br><span class="line">    <span class="attr">id</span>: <span class="string">uid++,</span></span><br><span class="line">    <span class="attr">data</span>: <span class="string">item,</span></span><br><span class="line">    <span class="attr">vote</span>: <span class="string">0</span></span><br><span class="line">  <span class="attr">&#125;)</span></span><br><span class="line"><span class="attr">)</span></span><br></pre></td></tr></table></figure><p>已优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = items.map(</span><br><span class="line">  item =&gt; optimizeItem(item)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">optimizeItem</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> itemData = &#123;</span><br><span class="line">    id: uid++,</span><br><span class="line">    vote: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(itemData, <span class="string">&#x27;data&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// Mark as non-reactive</span></span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: item</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> itemData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先渲染用户可见的"><a href="#优先渲染用户可见的" class="headerlink" title="优先渲染用户可见的"></a>优先渲染用户可见的</h3><p>未优化</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">&quot;items no-v&quot;</span>&gt;</span><br><span class="line">  &lt;FetchItemViewFunctional</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">&quot;item of items&quot;</span></span><br><span class="line">    :key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">    :<span class="built_in">item</span>=<span class="string">&quot;item&quot;</span></span><br><span class="line">    @vote=<span class="string">&quot;voteItem(item)&quot;</span></span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>已优化</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">recycle-scroller</span></span></span></span><br><span class="line"><span class="xml">  class=&quot;items&quot;</span></span><br><span class="line"><span class="xml">  :items=&quot;items&quot;</span></span><br><span class="line"><span class="xml">  :item-size=&quot;24&quot;</span></span><br><span class="line"><span class="xml">&gt;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">&quot;</span></span></span><span class="template-variable">&#123; item &#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">FetchItemView</span></span></span></span><br><span class="line"><span class="xml">      :item=&quot;item&quot;</span></span><br><span class="line"><span class="xml">      @vote=&quot;voteItem(item)&quot;</span></span><br><span class="line"><span class="xml">    /&gt;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">recycle-scroller</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex问答</title>
      <link href="2019/04/05/vuex%E9%97%AE%E7%AD%94/"/>
      <url>2019/04/05/vuex%E9%97%AE%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h3 id="有用过vuex吗？它主要解决的是什么问题？推荐在哪些场景用？"><a href="#有用过vuex吗？它主要解决的是什么问题？推荐在哪些场景用？" class="headerlink" title="有用过vuex吗？它主要解决的是什么问题？推荐在哪些场景用？"></a>有用过vuex吗？它主要解决的是什么问题？推荐在哪些场景用？</h3><p>答: 我主要还是当全局变量来用的，比如登录人信息、token、浏览记录、跨组件的较大临时数据传递。<br>以往需要调个方法取全局变量或缓存，其实反而增加了初始化流程，而会自动更新的 vuex 就很好用了。</p><h3 id="vuex的store有几个属性值？分别讲讲它们的作用是什么？"><a href="#vuex的store有几个属性值？分别讲讲它们的作用是什么？" class="headerlink" title="vuex的store有几个属性值？分别讲讲它们的作用是什么？"></a>vuex的store有几个属性值？分别讲讲它们的作用是什么？</h3><p>答: state:存贮公共数据的地方<br>Getters：获取公共数据的地方<br>mutations：放的是同步的操作和reducer有点像 通过store的commit方法来让mutations执行<br>action：放的是异步的操作 通过dispatch的方法让action里面的方法执行<br>context是store的一个副本</p><p>Vuex就是提供一个仓库，store仓库里面放了很多对象其中state即使数据源存放地，</p><h3 id="页面刷新后vuex的state数据丢失怎么解决？"><a href="#页面刷新后vuex的state数据丢失怎么解决？" class="headerlink" title="页面刷新后vuex的state数据丢失怎么解决？"></a>页面刷新后vuex的state数据丢失怎么解决？</h3><p>答:其实很简单，因为store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值。<br>在这个Vue单页应用中，王二是用Vuex作为状态管理的，一开始王二的思路是将Vuex里的数据同步更新到localStorage里。<br>即：一改变vuex里的数据,便触发localStorage.setItem 方法，参考如下代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line">import Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">function storeLocalStore (<span class="keyword">state</span>) &#123;</span><br><span class="line">    window.localStorage.<span class="built_in">set</span>Item(<span class="string">&quot;userMsg&quot;</span>,JSON.stringify(<span class="keyword">state</span>));</span><br><span class="line">&#125;</span><br><span class="line">export <span class="keyword">default</span> new Vuex.Store(&#123;</span><br><span class="line">    <span class="keyword">state</span>: &#123;</span><br><span class="line">        username: <span class="string">&quot;王二&quot;</span>,</span><br><span class="line">        schedulename: <span class="string">&quot;标题&quot;</span>,</span><br><span class="line">        scheduleid: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        storeUsername (<span class="keyword">state</span>,name) &#123;</span><br><span class="line">            <span class="keyword">state</span>.username = name</span><br><span class="line">            storeLocalStore (<span class="keyword">state</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        storeSchedulename (<span class="keyword">state</span>,name) &#123;</span><br><span class="line">            <span class="keyword">state</span>.schedulename = name</span><br><span class="line">            storeLocalStore (<span class="keyword">state</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        storeScheduleid (<span class="keyword">state</span>,id) &#123;</span><br><span class="line">            <span class="keyword">state</span>.scheduleid = Number(id)</span><br><span class="line">            storeLocalStore (<span class="keyword">state</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在页面加载时再从localStorage里将数据取回来放到vuex里，于是王二在 App.vue 的 created 钩子函数里写下了如下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localStorage.get<span class="constructor">Item(<span class="string">&quot;userMsg&quot;</span>)</span><span class="operator"> &amp;&amp; </span>this.$store.replace<span class="constructor">State(JSON.<span class="params">parse</span>(<span class="params">localStorage</span>.<span class="params">getItem</span>(<span class="string">&quot;userMsg&quot;</span>)</span>));</span><br><span class="line"><span class="comment">//考虑到第一次加载项目时localStorage里没有userMsg的信息，所以在前面要先做判断</span></span><br></pre></td></tr></table></figure><p>以上的解决方法由于要频繁地触发 localStorage.setItem 方法，所以对性能很不友好。而且如果一直同步vuex里的数据到localStorage里，我们直接用localStorage做状态管理好了，似乎也没有必要再用vuex。<br>这时候王二想，如果有什么方法能够监听到页面的刷新事件，然后在那个监听方法里将Vuex里的数据储存到localStorage里，那该多好。<br>很幸运，还真有这样的监听事件，我们可以用 beforeunload 来达到以上目的，于是王二在 App.vue 的 created 钩子函数里写下了如下代码：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>在页面加载时读取<span class="built_in">localStorage</span>里的状态信息</span><br><span class="line">   <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;userMsg&quot;</span>) &amp;&amp; <span class="built_in">this</span>.$store.replaceState(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;userMsg&quot;</span>)));</span><br><span class="line">   </span><br><span class="line">   <span class="regexp">//</span>在页面刷新时将vuex里的信息保存到<span class="built_in">localStorage</span>里</span><br><span class="line">   <span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>,<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;userMsg&quot;</span>,<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.$store.state))</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>这样的话，似乎就比较完美了。<br>王二在使用上述方法时，遇到了一个问题，就是：在开发阶段，如果在Vuex里添加新的字段，则新的字段不能被保存到localStorage里，于是上述代码修改如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在页面加载时读取localStorage里的状态信息</span></span><br><span class="line">localStorage.get<span class="constructor">Item(<span class="string">&quot;userMsg&quot;</span>)</span><span class="operator"> &amp;&amp; </span>this.$store.replace<span class="constructor">State(Object.<span class="params">assign</span>(<span class="params">this</span>.$<span class="params">store</span>.<span class="params">state</span>,JSON.<span class="params">parse</span>(<span class="params">localStorage</span>.<span class="params">getItem</span>(<span class="string">&quot;userMsg&quot;</span>)</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//在页面刷新时将vuex里的信息保存到localStorage里</span></span><br><span class="line">window.add<span class="constructor">EventListener(<span class="string">&quot;beforeunload&quot;</span>,()</span>=&gt;&#123;</span><br><span class="line">    localStorage.set<span class="constructor">Item(<span class="string">&quot;userMsg&quot;</span>,JSON.<span class="params">stringify</span>(<span class="params">this</span>.$<span class="params">store</span>.<span class="params">state</span>)</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意:存到缓存里必须用JSON.stringify方法来转换为字符串,再用JSON.parse方法来从缓存取出</p><h3 id="请求数据是写在组件的methods中还是在vuex的action中？"><a href="#请求数据是写在组件的methods中还是在vuex的action中？" class="headerlink" title="请求数据是写在组件的methods中还是在vuex的action中？"></a>请求数据是写在组件的methods中还是在vuex的action中？</h3><p>如果您使用vuex的话，建议您存入vuex中，因为actions可以执行异步操作。同上，简单的页面放在methods里面即可。比较复杂，或者重要建议放在vuex中，容易维护，代码清晰,并且调用简单，这个在项目后期很重要。</p><h3 id="vuex使用actions时不支持多参数传递怎么办？"><a href="#vuex使用actions时不支持多参数传递怎么办？" class="headerlink" title="vuex使用actions时不支持多参数传递怎么办？"></a>vuex使用actions时不支持多参数传递怎么办？</h3><p>一个Object解决所有问题</p><h3 id="你有使用过vuex的module吗？主要是在什么场景下使用？"><a href="#你有使用过vuex的module吗？主要是在什么场景下使用？" class="headerlink" title="你有使用过vuex的module吗？主要是在什么场景下使用？"></a>你有使用过vuex的module吗？主要是在什么场景下使用？</h3><p>使用单一的状态树，应用的所有状态都会集中在一个比较大的对象上面，随着项目需求的不断增加，状态树也会变得越来越臃肿，增加了状态树维护的复杂度,而且代码变得沉长；因此我们需要modules来为我们的状态树分隔成不同的模块，每个模块拥有自己的state，getters，mutations，actions；而且允许每个module里面嵌套子module；如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">└── store</span><br><span class="line">    ├── index.<span class="keyword">js </span>         <span class="comment"># 我们组装模块并导出 store 的地方</span></span><br><span class="line">    ├── actions.<span class="keyword">js </span>       <span class="comment"># 根级别的 action</span></span><br><span class="line">    ├── mutations.<span class="keyword">js </span>     <span class="comment"># 根级别的 mutation</span></span><br><span class="line">    ├── state.<span class="keyword">js </span>         <span class="comment"># 根级别的 state</span></span><br><span class="line">    └── modules</span><br><span class="line">        ├── module1.<span class="keyword">js </span>  <span class="comment"># 模块1的state树</span></span><br><span class="line">        └── module2.<span class="keyword">js </span>  <span class="comment"># 模块2的state树</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack使用</title>
      <link href="2019/03/24/webpack%E4%BD%BF%E7%94%A8/"/>
      <url>2019/03/24/webpack%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(directory, useSubdirectories = <span class="literal">true</span>, regExp = <span class="regexp">/^\.\/.*$/</span>, mode = <span class="string">&#x27;sync&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(<span class="string">&#x27;./test&#x27;</span>, <span class="literal">false</span>, <span class="regexp">/\.test\.js$/</span>);</span><br><span class="line"><span class="built_in">require</span>.context(<span class="string">&#x27;../&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/\.stories\.js$/</span>);</span><br></pre></td></tr></table></figure><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ol><li>该方法的三个参数<ul><li>上下文，即目录路径</li><li>是否所搜子目录</li><li>匹配正则表达式</li></ul></li><li>导出功能context的3个属性<ul><li>resolve 函数，传入参数key返回该key模块的id</li><li>keys 模块路径组成的数组</li><li>id 上下文路径</li></ul></li></ol><h4 id="实际应用-引入eacharts地图中每个省份"><a href="#实际应用-引入eacharts地图中每个省份" class="headerlink" title="实际应用:引入eacharts地图中每个省份"></a>实际应用:引入eacharts地图中每个省份</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rjs = <span class="keyword">require</span>.context(<span class="string">&#x27;echarts/map/js/province&#x27;</span>)</span><br><span class="line">rjs.keys().<span class="keyword">forEach</span>(rjs)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git rebase与git merge的区别</title>
      <link href="2019/02/18/git%E7%9F%A5%E8%AF%86%E7%82%B9-rebase/"/>
      <url>2019/02/18/git%E7%9F%A5%E8%AF%86%E7%82%B9-rebase/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>主要区别在于git log上：是否保留分支的commit提交节点 。</p><h3 id="rebase到底是什么"><a href="#rebase到底是什么" class="headerlink" title="rebase到底是什么"></a>rebase到底是什么</h3><p>rebase就是——变基， 变基， 变基 。就是把所有分支拉直了,变成一条分支</p><p>即：改变一条分支的 基点 ，使原分支从指定的节点（commit）延续。。</p><p>通俗点讲，变基操作其实就是保留了该 commit 作出的修改，但删丢弃了分支上一些现有的提交记录，删去了这些节点。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>比较</th><th align="center">merge</th><th align="right">rebase</th></tr></thead><tbody><tr><td>优点</td><td align="center">保留有价值的历史文档</td><td align="right">删减就繁</td></tr><tr><td>缺点</td><td align="center">分支杂乱冗余</td><td align="right">无法体现时间线</td></tr></tbody></table><p>所以，使用merge还是rebase还是得分情况考虑，具体项目具体分析：</p><ul><li>如果项目庞大，需要一个简洁的线性历史树便于leader管理，推荐使用 git rebase 。</li><li>如果是小型项目，需要审查历史纪录来便于编写过程报告，则推荐使用 git merge 。</li></ul><p><img src="/2019/02/18/git%E7%9F%A5%E8%AF%86%E7%82%B9-rebase/merge.jpg" alt="merge"><br><img src="/2019/02/18/git%E7%9F%A5%E8%AF%86%E7%82%B9-rebase/rebase.jpg" alt="rebase"></p>]]></content>
      
      
      <categories>
          
          <category> 零散知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2019/02/17/hello-world/"/>
      <url>2019/02/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
